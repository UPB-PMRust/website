---
layout: section
---
# SPI
Serial Peripheral Interface

---

# Bibliography
for this section

1. **Raspberry Pi Ltd**, *[RP2350 Datasheet](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf)*
   - Chapter 12 - *Peripherals*
     - Chapter 12.3 - *SPI*

2. **STMicroelectronics**, *[STM32U545RE Reference Manual](https://www.st.com/resource/en/reference_manual/rm0456-stm32u5-series-armbased-32bit-mcus-stmicroelectronics.pdf)*
   - Chapter 68 - *Serial Peripheral Interface*

3. **Paul Denisowski**, *[Understanding SPI](https://www.youtube.com/watch?v=0nVNwozXsIc)*

---

# SPI
a.k.a *spy*

- Used for communication between integrated circuits
- Sensors usually expose an *SPI* and an *I2C* interface
- Two device types:
  - *main* (master) - controls the communication (usually MCU)
  - *sub* (slave) - receive and transmit data when the *main* requests (usually the sensor)


<div align="center">
<img src="./spi_network.svg" class="rounded w-120" style="background-color: white; padding: 5px;">
</div>

---

# Wires
3 + n

- *MOSI* - **M**ain **O**ut **S**ub **I**n - carries data from the **main** to the **subs**
- *MISO* - **M**ain **I**n **S**ub **O**ut - carries data from the active **sub** to the **main**
- *CLK* - Clock - the clock signal generated by the **main**, **subs** sample and write data to the bus only on the clock edge
- *CS** - **C**hip **S**elect - not actually part of SPI, one wire / sub, activates **one sub at a time**
  - inactive subs have to disconnect from the *MOSI* and *MISO* lines

<div grid="~ cols-2 gap-5">

<div align="center">
<img src="./spi_example.svg" class="rounded w-12f0">
</div>

<div align="center">
<img src="./spi_network.svg" class="rounded w-120" style="background-color: white; padding: 5px;">
</div>

</div>

---
layout: two-cols
---

# Transmission Example

<v-clicks>

1. **main** activates the sub device
   - sets the `CS` signal to `LOW`
3. at the same time
   - **main** puts the first bit on the `MOSI` line
   - **sub** puts the first bit on the `MISO` line
3. **main** starts the clock
4. at the *rising edge*
   -  **main** reads the data from the `MISO` line
   -  **sub** reads the data from the `MOSI` line
5. on the *falling edge*
   - **main** puts the next bit on the `MOSI` line
   - **sub** puts the next bit on the `MISO` line
6. repeat 4 and 5 until **main** decides to stop the clock

</v-clicks>


:: right ::

SPI Signals

<div align="center">
<img src="./spi_example.svg" class="rounded w-120">
</div>

SPI Network

<div align="center">
<img src="./spi_main_sub.svg" class="rounded w-120" style="background-color: white; padding: 5px;">
</div>

---
layout: two-cols
---

# SPI Modes
when data is read and written

| Mode | `CPOL` | `CPHA` |
|-|-|-|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 2 | 1 | 0 |
| 3 | 1 | 1 |

<style>
.two-columns {
    grid-template-columns: 3fr 9fr;
}
</style>

:: right ::

<div align="center">
<img src="./spi_variants.svg" class="rounded w-138">
</div>

| | | |
|-|-|-|
| `CPOL` | Clock polarity | The idle level of the clock when no data is being sent.<br> 0: *Clock is LOW when idle.* <br> 1: *Clock is HIGH when idle.* |
| `CPHA` | Clock phase | That clock edge used to read the data bit. <br> 0: Data sampled on the 1<sup>st</sup> clock edge (*the leading edge*). <br> 1: Data sampled on the 2<sup>nd</sup> clock edge (*the trailing edge*). |

---

# Transmission Example
one main, two subs

<div align="center">
<img src="./spi_network_transmission.svg" class="rounded">
</div>

<div grid="~ cols-2 gap-5">

<div>

1. **main** activates the CS pin of **sub 1**
2. **main** writes the first bit on MOSI, **sub 1** writes the first bit on MISO
3. **main** starts the clock
4. **main** and **sub 1** send the rest of the bits
5. **main** stops the clock
6. **main** deactivates the CS pin of **sub 1**

</div>

<div>

7. **main** activates the CS pin of **sub 2**
8. **main** writes the first bit on MOSI, **sub 2** writes the first bit on MISO
9. **main** starts the clock
10. **main** and **sub 2** send the rest of the bits
11. **main** stops the clock
12. **main** deactivates the CS pin of **sub 2**

</div>

</div>


---
layout: two-cols
---

# Daisy Chaining
using several SPI devices together

<v-clicks depth="2">

1. **main** activates all the **subs**
2. on the clock edge
   - **main** sends data to **sub 1**
   - **sub 1**[^sub_data] sends data to **sub 2**
   - ...
   - **sub n-1** sends data to **sub n**
   - **sub n** sends data to **main**

</v-clicks>

[^sub_data]: usually **subs** send the previous data bit received from **main** to the **next sub**

<style>
.two-columns {
    grid-template-columns: 3fr 5fr;
}
</style>

:: right ::

activate all the **sub** devices

<div align="center">
<img src="./spi_daisy.svg" class="rounded" style="background-color: white; padding: 5px;">
</div>

<div align="center">
<img src="./spi_leds.jpg" class="rounded w-90">
</div>

---
---
# Facts

| | | |
|-|-|-|
| Transmission | *duplex* | data must be sent in both directions at the same time |
| Clock | *synchronized* | the **main** and **sub** use the same clock, there is no need for clock synchronization |
| Wires | *MISO* / *MOSI* / *CLK* / *CS* | different read and write wires, a clock wire and an *optional* chip select wire for every sub |
| Devices | *1 main* <br> *several subs* | a receiver and a transmitter |
| Speed | *no limit* | does not have any limit, it is limited by the **main** clock and the electronics wirings |

---

# Usage

- EEPROMs / Flash (usually in *QSPI* mode)
  - Raspberry Pi Pico has its 2MB Flash connected using *QSPI*
- sensors / small displays
- RP2350 has two SPI devices
- STM32U545RE has two full SPI devices and one limited SPI device

<div grid="~ cols-2 gap-5">

<div align="center">
<img src="../rp2350/pico2w-pinout.svg" class="rounded m-5 w-100" style="background-color: white; padding: 5px;">
</div>

<div></div>

</div>

---

# Synchronous Embassy API - RP2350

<div grid="~ cols-3 gap-5">

```rust {*}{lines: false}
pub struct Config {
  pub frequency: u32,
  pub phase: Phase,
  pub polarity: Polarity,
}
```

```rust {*}{lines: false}
pub enum Phase {
  CaptureOnFirstTransition,
  CaptureOnSecondTransition,
}
```

```rust {*}{lines: false}
pub enum Polarity {
  IdleLow,
  IdleHigh,
}
```

</div>

```rust {1|2|2,3|5-7|5-8|10,11|13|13,14|13,14,15|13,14,15,16|all}
use embassy_rp::spi::Config as SpiConfig;
let mut config = SpiConfig::default();
config.frequency = 2_000_000;

let miso = p.PIN_12;
let mosi = p.PIN_11;
let clk = p.PIN_10;
let mut spi = Spi::new_blocking(p.SPI1, clk, mosi, miso, config);

// Configure CS
let mut cs = Output::new(p.PIN_X, Level::High);

cs.set_low();
let mut buf = [0x90, 0x00, 0x00, 0xd0, 0x00, 0x00];
spi.blocking_transfer_in_place(&mut buf);
cs.set_high();
```

---

# Synchronous Embassy API - STM32U545RE

<div grid="~ cols-4 gap-1">

```rust {*}{lines: false}
pub struct Config {
  pub mode: Mode,
  pub bit_order: BitOrder,
  pub frequency: Hertz,
  pub miso_pull: Pull,
  pub gpio_speed: Speed,
}
```

```rust {*}{lines: false}
pub struct Mode {
  pub polarity: Polarity,
  pub phase: Phase,
}
pub enum Polarity {
  IdleLow, IdleHigh,
}
```

```rust {*}{lines: false}
pub enum Phase {
 CaptureOnFirstTransition,
 CaptureOnSecondTransition,
}
pub enum BitOrder {
  LsbFirst, MsbFirst,
}
```

```rust {*}{lines: false}
pub enum Speed { Low,
    Medium, High, VeryHigh,
}
```

</div>

```rust {1|2|2,3|5-7|5-8|10,11|13|13,14|13,14,15|13,14,15,16|all}
use embassy_stm32::spi::Config as SpiConfig;
let mut config = SpiConfig::default();
config.frequency = Hertz(1_000_000);

let miso = p.PA6;
let mosi = p.PA7;
let clk = p.PA5;
let mut spi = Spi::new_blocking(p.SPI1, clk, mosi, miso, config);

// Configure CS
let mut cs = Output::new(p.PXn, Level::High, Speed::Low);

cs.set_low();
let mut buf = [0x90, 0x00, 0x00, 0xd0, 0x00, 0x00];
spi.blocking_transfer_in_place(&mut buf);
cs.set_high();
```

---

# Asynchronous Embassy API
for RP2040

```rust {1|2|2,3|5-7|5-8|10,11|13|13,14,15|13,14,15,16|13,14,15,16,17|all}
use embassy_rp::spi::Config as SpiConfig;
let mut config = SpiConfig::default();
config.frequency = 1_000_000;

let miso = p.PIN_12;
let mosi = p.PIN_11;
let clk = p.PIN_10;
let mut spi = Spi::new(p.SPI1, clk, mosi, miso, p.DMA_CH0, p.DMA_CH1, config);

// Configure CS
let mut cs = Output::new(p.PIN_X, Level::High);

cs.set_low();
let tx_buf = [1_u8, 2, 3, 4, 5, 6];
let mut rx_buf = [0_u8; 6];
spi.transfer(&mut rx_buf, &tx_buf).await;
cs.set_high();
```

---

# Asynchronous Embassy API
for STM32U545RE

```rust {1|2|2,3|5-7|5-8|10,11|13|13,14,15|13,14,15,16|13,14,15,16,17|all}
use embassy_stm32::spi::Config as SpiConfig;
let mut config = SpiConfig::default();
config.frequency = Hertz(1_000_000);

let miso = p.PIN_12;
let mosi = p.PIN_11;
let clk = p.PIN_10;
let mut spi = Spi::new(p.SPI1, clk, mosi, miso, p.GPDMA1_CH0, p.GPDMA1_CH1, config);

// Configure CS
let mut cs = Output::new(p.PIN_X, Level::High, Speed::Low);

cs.set_low();
let tx_buf = [1_u8, 2, 3, 4, 5, 6];
let mut rx_buf = [0_u8; 6];
spi.transfer(&mut rx_buf, &tx_buf).await;
cs.set_high();
```
