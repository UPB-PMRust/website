"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4239],{41323:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"tutorial/bitwise-operations","title":"Bitwise Operations in Rust","description":"Bitwise operations to interact with hardware registers in Rust","source":"@site/versioned_docs/version-fils_en/tutorial/bitwise-operations.md","sourceDirName":"tutorial","slug":"/tutorial/bitwise-operations","permalink":"/docs/fils_en/tutorial/bitwise-operations","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/tutorial/bitwise-operations.md","tags":[],"version":"fils_en","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"Bitwise operations to interact with hardware registers in Rust"},"sidebar":"tutorialSidebar","previous":{"title":"Tutorials","permalink":"/docs/fils_en/category/tutorials"},"next":{"title":"KiCad setup","permalink":"/docs/fils_en/tutorial/kicad"}}');var n=s(74848),r=s(28453);const o={sidebar_position:1,description:"Bitwise operations to interact with hardware registers in Rust"},a="Bitwise Operations in Rust",l={},c=[{value:"The Anatomy of a Hardware Register",id:"the-anatomy-of-a-hardware-register",level:2},{value:"Bit Shifting",id:"bit-shifting",level:2},{value:"Modifying Registers",id:"modifying-registers",level:2},{value:"Setting Bits (Making them <code>1</code>)",id:"setting-bits-making-them-1",level:3},{value:"Clearing Bits (Making them <code>0</code>)",id:"clearing-bits-making-them-0",level:3},{value:"Toggling / Flipping Bits",id:"toggling--flipping-bits",level:3},{value:"Value Extraction(Masking)",id:"value-extractionmasking",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function d(e){const i={admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mdxAdmonitionTitle:"mdxAdmonitionTitle",mi:"mi",mn:"mn",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"bitwise-operations-in-rust",children:"Bitwise Operations in Rust"})}),"\n",(0,n.jsxs)(i.p,{children:["When developing embedded software for the ",(0,n.jsx)(i.strong,{children:"STM32 Nucleo-U545RE-Q"}),", you are frequently required to configure specific hardware peripherals. Whether you are turning on one of the 5 LEDs or reading the state of the 4 buttons  on your lab board, you communicate with the microcontroller by modifying specific bits within its hardware registers."]}),"\n",(0,n.jsx)(i.p,{children:"Because hardware registers group multiple independent configuration settings into a single 32-bit (or 8-bit) word, you cannot simply overwrite the entire register without risking the disruption of other settings. This is where bitwise operations come in."}),"\n",(0,n.jsx)(i.h2,{id:"the-anatomy-of-a-hardware-register",children:"The Anatomy of a Hardware Register"}),"\n",(0,n.jsx)(i.p,{children:"Registers in microcontrollers generally consist of bits grouped by their specific roles. Here is what those bits actually do under the hood:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Control bits"}),": These are used to control different operating modes of the microcontroller or to activate specific hardware components. For example, setting a specific control bit might turn on the UART communication peripheral."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Status bits"}),": These are generally read-only bits used to check the state of an action or hardware peripheral. For instance, a status bit might turn to ",(0,n.jsx)(i.code,{children:"1"})," automatically when new data has arrived in a buffer."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Data bits"}),": These bits are used to provide the microcontroller with data to be processed, or to retrieve data from it."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Reserved bits"}),": These bits are not currently used by the microcontroller. As a general rule in embedded programming, you should never modify reserved bits."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"bit-shifting",children:"Bit Shifting"}),"\n",(0,n.jsxs)(i.p,{children:["Before modifying registers, you need to know how to target a specific bit. We do this by taking the number ",(0,n.jsx)(i.code,{children:"1"}),' and "shifting" it to the correct position.']}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Right Shift (",(0,n.jsx)(i.code,{children:">>"}),"): This moves each bit of the operand to the right by a specified number of positions. Zeros are added to the left to maintain the dimension of the number. Mathematically, shifting right is a highly efficient way to divide a binary number by ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msup,{children:[(0,n.jsx)(i.mn,{children:"2"}),(0,n.jsx)(i.mi,{children:"n"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"2^n"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6644em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord",children:"2"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsx)(i.span,{className:"vlist-t",children:(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.6644em"},children:(0,n.jsxs)(i.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"n"})})]})})})})})]})]})})]})," in a single operation."]}),"\n"]}),"\n",(0,n.jsx)(i.admonition,{type:"info",children:(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"1010 >> 1 = 0101"})," (In decimal: 10 divided by 2 becomes 5)."]})}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Left Shift (",(0,n.jsx)(i.code,{children:"<<"}),"): Moves bits to the left, filling the empty spaces on the right with zeros. Shifting left by n is mathematically equivalent to multiplying by ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msup,{children:[(0,n.jsx)(i.mn,{children:"2"}),(0,n.jsx)(i.mi,{children:"n"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"2^n"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6644em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord",children:"2"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsx)(i.span,{className:"vlist-t",children:(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.6644em"},children:(0,n.jsxs)(i.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"n"})})]})})})})})]})]})})]}),"."]}),"\n"]}),"\n",(0,n.jsx)(i.admonition,{type:"info",children:(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"0011 << 1 = 0110"})," (In decimal: 3 multiplied by 2 becomes 6)."]})}),"\n",(0,n.jsx)(i.h2,{id:"modifying-registers",children:"Modifying Registers"}),"\n",(0,n.jsx)(i.p,{children:"Here are the primary operations you will use daily to manipulate bits without corrupting the rest of the register."}),"\n",(0,n.jsxs)(i.h3,{id:"setting-bits-making-them-1",children:["Setting Bits (Making them ",(0,n.jsx)(i.code,{children:"1"}),")"]}),"\n",(0,n.jsxs)(i.p,{children:["To set a specific bit to ",(0,n.jsx)(i.code,{children:"1"})," while leaving the rest of the register untouched, we use the bitwise ",(0,n.jsx)(i.strong,{children:"OR"})," (",(0,n.jsx)(i.code,{children:"|"}),") operator."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Set a single bit"}),": ",(0,n.jsx)(i.code,{children:"register | 1 << bit"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Set multiple bits"}),": ",(0,n.jsx)(i.code,{children:"register | bits"})]}),"\n"]}),"\n",(0,n.jsxs)(i.h3,{id:"clearing-bits-making-them-0",children:["Clearing Bits (Making them ",(0,n.jsx)(i.code,{children:"0"}),")"]}),"\n",(0,n.jsxs)(i.p,{children:["To clear a specific bit to ",(0,n.jsx)(i.code,{children:"0"}),", we use a combination of the bitwise ",(0,n.jsx)(i.strong,{children:"AND"})," (",(0,n.jsx)(i.code,{children:"&"}),") and bitwise ",(0,n.jsx)(i.strong,{children:"NOT"})," (",(0,n.jsx)(i.code,{children:"!"}),") operators."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Clear a single bit"}),": ",(0,n.jsx)(i.code,{children:"register & !(1 << bit)"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Clear multiple bits"}),": ",(0,n.jsx)(i.code,{children:"register & !bits"})]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"toggling--flipping-bits",children:"Toggling / Flipping Bits"}),"\n",(0,n.jsxs)(i.p,{children:["If you need to invert the current state of a bit (change ",(0,n.jsx)(i.code,{children:"1"})," to ",(0,n.jsx)(i.code,{children:"0"}),", or ",(0,n.jsx)(i.code,{children:"0"})," to ",(0,n.jsx)(i.code,{children:"1"}),"), use the bitwise ",(0,n.jsx)(i.strong,{children:"XOR"})," (",(0,n.jsx)(i.code,{children:"^"}),") operator."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Flip a single bit"}),": ",(0,n.jsx)(i.code,{children:"register ^ (1 << bit)"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Flip multiple bits"}),": ",(0,n.jsx)(i.code,{children:"register ^ bits"})]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"value-extractionmasking",children:"Value Extraction(Masking)"}),"\n",(0,n.jsxs)(i.p,{children:['Often, a hardware register contains a specific multi-bit "field" (like a 4-bit configuration value) packed into a larger 32-bit word. To read just that field, you need to shift the bits down to the zero position and apply a ',(0,n.jsx)(i.strong,{children:"Mask"})," to zero-out everything else."]}),"\n",(0,n.jsx)(i.p,{children:"Here is a practical example of extracting a specific portion of a 32-bit ID:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:"// We define a mask that isolates the bottom 12 bits\nconst MASK: u32 = 0b0000_0000_0000_0000_0000_1111_1111_1111;\n\nfn main() {\n    // A 32-bit register value\n    let large_id: u32 = 0b1100_1010_1111_1100_0000_1111_0110_1101;\n    \n    // 1. Shift right by 20 to bring the target bits to the bottom\n    // 2. Apply the AND mask to clear all upper bits\n    let extracted_bits = (large_id >> 20) & MASK; \n\n    // Result: 00000000_0000_0000_0000_1100_1010_1111 \n}\n"})}),"\n",(0,n.jsx)(i.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,n.jsx)(i.p,{children:"Bitwise operations are prone to logical typos. Watch out for these common errors:"}),"\n",(0,n.jsxs)(i.admonition,{type:"warning",children:[(0,n.jsx)(i.mdxAdmonitionTitle,{}),(0,n.jsxs)(i.p,{children:["Using the assignment operator (",(0,n.jsx)(i.code,{children:"="}),") instead of the compound bitwise operator (",(0,n.jsx)(i.code,{children:"|="})," or ",(0,n.jsx)(i.code,{children:"&="}),")."]}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Wrong"}),": ",(0,n.jsx)(i.code,{children:"register = 1 << 4"})," (This wipes out the entire register and only sets bit 4)"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Correct"}),": ",(0,n.jsx)(i.code,{children:"register |= 1 << 4"})," (This preserves the rest of the register while setting bit 4)."]}),"\n"]})]}),"\n",(0,n.jsxs)(i.admonition,{type:"warning",children:[(0,n.jsx)(i.mdxAdmonitionTitle,{}),(0,n.jsxs)(i.p,{children:["Do not confuse ",(0,n.jsx)(i.strong,{children:"logical"})," operators with ",(0,n.jsx)(i.strong,{children:"bitwise"})," operators!"]}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"&&"})," and ",(0,n.jsx)(i.code,{children:"||"})," evaluate truthiness (e.g., ",(0,n.jsx)(i.code,{children:"true && false"}),")"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"&"})," and ",(0,n.jsx)(i.code,{children:"|"})," perform mathematically accurate bit-by-bit operations (e.g., ",(0,n.jsx)(i.code,{children:"0b1100 & 0b0101 = 0b0100"}),")."]}),"\n"]})]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>a});var t=s(96540);const n={},r=t.createContext(n);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);