"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[868],{39398:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"lab/00.1","title":"00.1 - Deep dive in Rust","description":"Recap and deep dive into ownership, borrowing, and the Copy trait","source":"@site/versioned_docs/version-acs_cc/lab/00.1.md","sourceDirName":"lab","slug":"/lab/00.1","permalink":"/docs/acs_cc/lab/00.1","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/lab/00.1.md","tags":[],"version":"acs_cc","frontMatter":{"description":"Recap and deep dive into ownership, borrowing, and the Copy trait"},"sidebar":"tutorialSidebar","previous":{"title":"00.0 - Intro to Rust","permalink":"/docs/acs_cc/lab/00.0"},"next":{"title":"01 - Debug","permalink":"/docs/acs_cc/lab/01"}}');var r=s(74848),i=s(28453);const o={description:"Recap and deep dive into ownership, borrowing, and the Copy trait"},a="00.1 - Deep dive in Rust",l={},c=[{value:"Resources",id:"resources",level:2},{value:"Ownership",id:"ownership",level:2},{value:"Ownership rules",id:"ownership-rules",level:3},{value:"Scope",id:"scope",level:3},{value:"Ownership in functions",id:"ownership-in-functions",level:3},{value:"Return values and scope",id:"return-values-and-scope",level:3},{value:"References and borrowing",id:"references-and-borrowing",level:3},{value:"Mutable references",id:"mutable-references",level:3},{value:"Copy trait",id:"copy-trait",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Part A. Warm-up (recap Lab 00.0 concepts)",id:"part-a-warm-up-recap-lab-000-concepts",level:2},{value:"1. Clamp + casting",id:"1-clamp--casting",level:3},{value:"2. Adjacent sums",id:"2-adjacent-sums",level:3},{value:"3. Enum + match: log formatting",id:"3-enum--match-log-formatting",level:3},{value:"4. First \u201cword\u201d longer than N",id:"4-first-word-longer-than-n",level:3},{value:"Part B. Ownership, borrowing, mutable references, Copy",id:"part-b-ownership-borrowing-mutable-references-copy",level:2},{value:"5) \u201cWhy doesn\u2019t this compile?\u201d (fix with minimal edits)",id:"5-why-doesnt-this-compile-fix-with-minimal-edits",level:3},{value:"6. Split a Vec without cloning",id:"6-split-a-vec-without-cloning",level:3},{value:"7. Mutate a String in place",id:"7-mutate-a-string-in-place",level:3},{value:"8. Return a slice (borrowing)",id:"8-return-a-slice-borrowing",level:3},{value:"9. Copy vs non-Copy: make a tiny math type",id:"9-copy-vs-non-copy-make-a-tiny-math-type",level:3},{value:"10. Inventory (ownership + borrowing + Result)",id:"10-inventory-ownership--borrowing--result",level:3},{value:"11. Deduplicate in place",id:"11-deduplicate-in-place",level:3},{value:"Rust Playground Worksheet (paste into Playground, then click <strong>Test</strong>)",id:"rust-playground-worksheet-paste-into-playground-then-click-test",level:2},{value:"Bonus at home",id:"bonus-at-home",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"001---deep-dive-in-rust",children:"00.1 - Deep dive in Rust"})}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The Rust Programming Language, Chapter ",(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",children:"4"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://tourofrust.com",children:"Tour of Rust"})," step by step tutorial"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Let's Get Rusty"})," - ",(0,r.jsx)(n.a,{href:"https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8",children:"The Rust Lang Book"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=VFIOSWy93H0",children:"Understanding Ownership in Rust"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"ownership",children:"Ownership"}),"\n",(0,r.jsx)(n.p,{children:"Ownership is a set of rules that govern how a Rust program manages memory. All programs must manage the way they use the memory of a computer while running."}),"\n",(0,r.jsxs)(n.p,{children:["Some languages have ",(0,r.jsx)(n.strong,{children:"garbage collection"})," that regularly searches for unused memory during program execution, in other languages, the programmer must explicitly allocate and release memory."]}),"\n",(0,r.jsxs)(n.p,{children:["Rust uses a third approach: the memory is managed via a ",(0,r.jsx)(n.strong,{children:"property system"})," with a set of ",(0,r.jsx)(n.strong,{children:"rules"})," that the compiler verifies. If one of the rules is violated, the program will not compile. None of the property characteristics will slow down your program during its execution."]}),"\n",(0,r.jsx)(n.h3,{id:"ownership-rules",children:"Ownership rules"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Each value in Rust has an ",(0,r.jsx)(n.strong,{children:"owner"})]}),"\n",(0,r.jsxs)(n.li,{children:["A value cannot have more than one ",(0,r.jsx)(n.strong,{children:"owner"})," at a time"]}),"\n",(0,r.jsx)(n.li,{children:"When the values are out of scope, they are dropped"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scope",children:"Scope"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"scope"})," is the code area of a program in which an element is valid."]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example to understand the concept:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'{\n    // Here s is invalid\n    let s = "hello";   // s is valid past this point\n} // after this the value s will be dropped\n'})}),"\n",(0,r.jsx)(n.h3,{id:"ownership-in-functions",children:"Ownership in functions"}),"\n",(0,r.jsx)(n.p,{children:"The mechanisms for transmitting a value to a function are similar to those of assigning a value to a variable. Parsing a variable to a function will move or copy, just as the assignment does."}),"\n",(0,r.jsx)(n.p,{children:"Example (read the comments):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s = String::from("hello");  // s comes into scope\n \n    takes_ownership(s);             // s\'s value moves into the function...\n                                    // ... and so is no longer valid here\n \n    let x = 5;                      // x comes into scope\n \n    makes_copy(x);                  // a copy of x is passed to the function,\n                                    // but i32 is Copy, so it\'s okay to still\n                                    // use x afterward\n \n} // Here, x goes out of scope, then s. But because s\'s value was moved, nothing\n  // special happens.\n \nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!("{}", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n \nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!("{}", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If we were trying to use s after the call to ",(0,r.jsx)(n.code,{children:"take_ownership"}),", Rust would return a compilation error. These static checks protect us from errors."]}),"\n",(0,r.jsx)(n.h3,{id:"return-values-and-scope",children:"Return values and scope"}),"\n",(0,r.jsx)(n.p,{children:"The return values can also transfer the ownership."}),"\n",(0,r.jsxs)(n.p,{children:["The ownership of a variable follows the same pattern each time: the assignment of one value to another variable moves it. When a variable that includes data on the heap comes out of the scope, the value will be cleaned by ",(0,r.jsx)(n.strong,{children:"drop"})," unless the data ownership has been moved to another variable."]}),"\n",(0,r.jsx)(n.p,{children:"Example (read the comments):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n \n    let s2 = String::from("hello");     // s2 comes into scope\n \n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n \nfn gives_ownership() -> String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n \n    let some_string = String::from("yours"); // some_string comes into scope\n \n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n \n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -> String { // a_string comes into\n                                                      // scope\n \n    a_string  // a_string is returned and moves out to the calling function\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"references-and-borrowing",children:"References and borrowing"}),"\n",(0,r.jsx)(n.p,{children:"A reference is like a pointer in the sense that it is an address that we can track to access the data stored at that address; these data belong to another variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the lifetime of this reference."}),"\n",(0,r.jsxs)(n.p,{children:["The symbol ",(0,r.jsx)(n.code,{children:"&"})," is used to mark a reference, either before the name of a variable, or, for the case of a parameter of a function, before the type of the parameter. These ampersands represent references and allow you to refer to a value without your own ownership."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let x: u16 = 10;\nlet y = &x;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example of a function which takes a reference to an object as a parameter instead of taking possession of this value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n \nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because it does not have ownership of what\n  // it refers to, it is not dropped.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The syntax ",(0,r.jsx)(n.code,{children:"&s1"})," allows us to create a reference that refers to the value of s1 but does not. Since the reference does not have the value to which it points, the value of s1 will not be deleted when the reference ceases to be used."]}),"\n",(0,r.jsx)(n.p,{children:"Similarly, the signature of the function uses & to indicate that the type of parameter s is a reference."}),"\n",(0,r.jsx)(n.p,{children:"We call borrowing the action of creating a reference. As in real life, you can borrow something from someone. When you don't need the borrowed thing anymore, you have to return it. You don't own it."}),"\n",(0,r.jsx)(n.p,{children:"Just as the variables are immutable by default, so are the references. We are not allowed to change the value pointed to by a reference"}),"\n",(0,r.jsx)(n.h3,{id:"mutable-references",children:"Mutable references"}),"\n",(0,r.jsxs)(n.p,{children:["If we want to change the value of a reference we have to say this explicitly to the compiler using the keyword ",(0,r.jsx)(n.code,{children:"mut"})," Mutable references have a great restriction: if you have a mutable reference to a value, you cannot have other references to that value."]}),"\n",(0,r.jsx)(n.p,{children:"Nor can we have a mutable reference while we have an immutable one to the same value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n \nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n'})}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsx)(n.p,{children:"Rules for references:"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"At any time, you can have only a mutable reference or any number of immutable references but not both."}),"\n",(0,r.jsxs)(n.li,{children:["References must always be ",(0,r.jsx)(n.strong,{children:"valid"}),"."]}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"copy-trait",children:"Copy trait"}),"\n",(0,r.jsx)(n.p,{children:"Let's take a similar code to the one presented before:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let mut x:i32 = 0;\nlet mut y = x;\ny = 5;\nprintln!("{x}"); // Prints 0\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This time, the compiler seems to not have moved the variable ",(0,r.jsx)(n.code,{children:"x"})," into ",(0,r.jsx)(n.code,{children:"y"}),". Why? Because i32 implements ",(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/core/marker/trait.Copy.html",children:(0,r.jsx)(n.code,{children:"Copy"})}),". This is a trait used for types that are inexpensive to duplicate bit by bit, and which also do not allow 2 mutable references to the same location in memory."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Implements Copy"}),(0,r.jsx)(n.th,{children:"Reason"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"i32"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"f64"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"String"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"It holds a pointer to its internal buffer. The buffer had to be duplicated when copying, action that a byte by byte copy is not able to do."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Vec<_>"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"It holds a pointer to its internal buffer. The buffer had to be duplicated when copying, action that a byte by byte copy is not able to do."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"&str"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"&mut str"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Copying would create another mutable reference to the same value."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["You may implement the ",(0,r.jsx)(n.code,{children:"Copy"})," trait to your structs and enums by using ",(0,r.jsx)(n.code,{children:"#[derive(Clone, Copy)]"})]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["You ",(0,r.jsx)(n.strong,{children:"must"})," implement ",(0,r.jsx)(n.code,{children:"Clone"})," trait in order to derive ",(0,r.jsx)(n.code,{children:"Copy"}),". Also, all of the fields must have types that implement ",(0,r.jsx)(n.code,{children:"Copy"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{}),(0,r.jsxs)(n.p,{children:["If you don't have Rust installed, you can use ",(0,r.jsx)(n.a,{href:"https://play.rust-lang.org/",children:"Rust Playground"})," to solve the topics."]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{}),(0,r.jsxs)(n.p,{children:["Use the worksheet at the bottom: paste it into ",(0,r.jsx)(n.a,{href:"https://play.rust-lang.org/",children:"Rust Playground"}),"  and click ",(0,r.jsx)(n.strong,{children:"Test"}),"."]})]}),"\n",(0,r.jsx)(n.h2,{id:"part-a-warm-up-recap-lab-000-concepts",children:"Part A. Warm-up (recap Lab 00.0 concepts)"}),"\n",(0,r.jsx)(n.h3,{id:"1-clamp--casting",children:"1. Clamp + casting"}),"\n",(0,r.jsxs)(n.p,{children:["Write a function that converts an ",(0,r.jsx)(n.code,{children:"i16"})," into a ",(0,r.jsx)(n.code,{children:"u8"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["values ",(0,r.jsx)(n.code,{children:"< 0"})," become ",(0,r.jsx)(n.code,{children:"0"})]}),"\n",(0,r.jsxs)(n.li,{children:["values ",(0,r.jsx)(n.code,{children:"> 255"})," become ",(0,r.jsx)(n.code,{children:"255"})]}),"\n",(0,r.jsx)(n.li,{children:"otherwise cast normally"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn clamp_u8(x: i16) -> u8\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-adjacent-sums",children:"2. Adjacent sums"}),"\n",(0,r.jsxs)(n.p,{children:["Given a slice, return a ",(0,r.jsx)(n.code,{children:"Vec<i32>"})," containing sums of adjacent pairs:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"[10, 20, 30] -> [30, 50]"})}),"\n",(0,r.jsx)(n.li,{children:"empty or length 1 -> empty vec"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn adjacent_sums(xs: &[i32]) -> Vec<i32>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-enum--match-log-formatting",children:"3. Enum + match: log formatting"}),"\n",(0,r.jsx)(n.p,{children:"Define:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"enum Log {\n    Info(String),\n    Warn(String),\n    Error { code: u16, msg: String },\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Write a function that turns a log into a single formatted line:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'Info("hi")'})," -> ",(0,r.jsx)(n.code,{children:'"[INFO] hi"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'Warn("careful")'})," -> ",(0,r.jsx)(n.code,{children:'"[WARN] careful"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'Error{code:7,msg:"bad"}'})," -> ",(0,r.jsx)(n.code,{children:'"[ERROR 7] bad"'})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn format_log(l: &Log) -> String\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-first-word-longer-than-n",children:"4. First \u201cword\u201d longer than N"}),"\n",(0,r.jsxs)(n.p,{children:["Given a sentence ",(0,r.jsx)(n.code,{children:"&str"}),", return the first whitespace-separated word with length strictly greater than ",(0,r.jsx)(n.code,{children:"n"}),".\nIf none, return ",(0,r.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn first_word_longer_than(s: &str, n: usize) -> Option<&str>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"part-b-ownership-borrowing-mutable-references-copy",children:"Part B. Ownership, borrowing, mutable references, Copy"}),"\n",(0,r.jsx)(n.h3,{id:"5-why-doesnt-this-compile-fix-with-minimal-edits",children:"5) \u201cWhy doesn\u2019t this compile?\u201d (fix with minimal edits)"}),"\n",(0,r.jsx)(n.p,{children:"Original snippet (doesn\u2019t compile):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("pico");\n    let a = &s;\n    s.push(\'!\'); // error: cannot borrow `s` as mutable because it is also borrowed as immutable\n    println!("{a}");\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Task: make it compile ",(0,r.jsx)(n.strong,{children:"without cloning"}),". You may only:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"move prints around"}),"\n",(0,r.jsx)(n.li,{children:"add/remove braces to shorten a borrow\u2019s scope"}),"\n",(0,r.jsxs)(n.li,{children:["optionally change ",(0,r.jsx)(n.code,{children:"&String"})," to ",(0,r.jsx)(n.code,{children:"&str"})," in your version"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Goal: prints something sensible and ends with ",(0,r.jsx)(n.code,{children:'s == "pico!"'}),"."]}),"\n",(0,r.jsx)(n.p,{children:"(Worksheet uses a helper function so this can be tested.)"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"6-split-a-vec-without-cloning",children:"6. Split a Vec without cloning"}),"\n",(0,r.jsxs)(n.p,{children:["Write a function that ",(0,r.jsx)(n.strong,{children:"consumes"})," a ",(0,r.jsx)(n.code,{children:"Vec<u8>"})," and returns two vectors:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["first contains the first ",(0,r.jsx)(n.code,{children:"n"})," elements (or all if shorter)"]}),"\n",(0,r.jsx)(n.li,{children:"second contains the rest"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"No cloning; move elements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn split_vec(v: Vec<u8>, n: usize) -> (Vec<u8>, Vec<u8>)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Hint: ",(0,r.jsx)(n.code,{children:"Vec::split_off"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"7-mutate-a-string-in-place",children:"7. Mutate a String in place"}),"\n",(0,r.jsxs)(n.p,{children:["Write a function that replaces the ",(0,r.jsx)(n.strong,{children:"first occurrence"})," of ",(0,r.jsx)(n.code,{children:"from"})," with ",(0,r.jsx)(n.code,{children:"to"})," inside ",(0,r.jsx)(n.code,{children:"s"}),".\nReturn ",(0,r.jsx)(n.code,{children:"true"})," if replacement happened, ",(0,r.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn replace_first(s: &mut String, from: &str, to: &str) -> bool\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Hint: ",(0,r.jsx)(n.code,{children:"find"})," + ",(0,r.jsx)(n.code,{children:"replace_range"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"8-return-a-slice-borrowing",children:"8. Return a slice (borrowing)"}),"\n",(0,r.jsxs)(n.p,{children:["Given a slice of integers, return a sub-slice from the start up to (but not including) the first ",(0,r.jsx)(n.code,{children:"0"}),".\nIf there\u2019s no zero, return the whole slice."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn until_zero(xs: &[i32]) -> &[i32]\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"9-copy-vs-non-copy-make-a-tiny-math-type",children:"9. Copy vs non-Copy: make a tiny math type"}),"\n",(0,r.jsxs)(n.p,{children:["Create a ",(0,r.jsx)(n.code,{children:"Point"})," that is ",(0,r.jsx)(n.strong,{children:"Copy"})," and implement:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"translate(p, dx, dy) -> Point"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"manhattan(a, b) -> u32"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Requirements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Point"})," derives ",(0,r.jsx)(n.code,{children:"Clone, Copy, Debug, PartialEq, Eq"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"10-inventory-ownership--borrowing--result",children:"10. Inventory (ownership + borrowing + Result)"}),"\n",(0,r.jsxs)(n.p,{children:["Implement a tiny inventory stored in a ",(0,r.jsx)(n.code,{children:"Vec<Item>"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Rules:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"add(name, qty)"})," adds qty (creates item if missing)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"take(name, qty)"})," subtracts qty","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"error if item missing"}),"\n",(0,r.jsx)(n.li,{children:"error if not enough quantity"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"qty(name)"})," returns current quantity as ",(0,r.jsx)(n.code,{children:"Option<u32>"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Hint: ",(0,r.jsx)(n.code,{children:"iter_mut()"})," for ",(0,r.jsx)(n.code,{children:"add/take"}),", ",(0,r.jsx)(n.code,{children:"iter()"})," for ",(0,r.jsx)(n.code,{children:"qty"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"11-deduplicate-in-place",children:"11. Deduplicate in place"}),"\n",(0,r.jsxs)(n.p,{children:["Remove duplicates from ",(0,r.jsx)(n.code,{children:"Vec<String>"})," ",(0,r.jsx)(n.strong,{children:"while preserving order"}),", in place."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub fn dedup_keep_order(xs: &mut Vec<String>)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Hint: ",(0,r.jsx)(n.code,{children:"retain"})," + ",(0,r.jsx)(n.code,{children:"std::collections::HashSet"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"rust-playground-worksheet-paste-into-playground-then-click-test",children:["Rust Playground Worksheet (paste into Playground, then click ",(0,r.jsx)(n.strong,{children:"Test"}),")"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// ================================\n// Lab 00.1 Worksheet (Rust Playground)\n// Paste this whole file into https://play.rust-lang.org/\n// Then click: "Test" to run the tests.\n// ================================\n\n#![allow(dead_code)]\n\n/* ------------------------------------------------\nEX 1) Clamp + casting\n------------------------------------------------ */\npub fn clamp_u8(x: i16) -> u8 {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 2) Adjacent sums\n------------------------------------------------ */\npub fn adjacent_sums(xs: &[i32]) -> Vec<i32> {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 3) Enum + match: log formatting\n------------------------------------------------ */\n#[derive(Debug)]\npub enum Log {\n    Info(String),\n    Warn(String),\n    Error { code: u16, msg: String },\n}\n\npub fn format_log(l: &Log) -> String {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 4) First word longer than N\n------------------------------------------------ */\npub fn first_word_longer_than(s: &str, n: usize) -> Option<&str> {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 5) Borrowing scope fix (no cloning)\nOriginal (doesn\'t compile):\nfn main() {\n    let mut s = String::from("pico");\n    let a = &s;\n    s.push(\'!\');\n    println!("{a}");\n}\nTask: fix borrowing scope.\n\nFor a testable worksheet, implement this function so it returns "pico!".\n(You can still add a println! inside if you want.)\n------------------------------------------------ */\npub fn ex5_borrow_demo() -> String {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 6) Split a Vec without cloning (move elements)\nHint: Vec::split_off\n------------------------------------------------ */\npub fn split_vec(v: Vec<u8>, n: usize) -> (Vec<u8>, Vec<u8>) {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 7) Mutate a String in place: replace first occurrence\nReturn true if replaced, false otherwise.\nHint: find + replace_range\n------------------------------------------------ */\npub fn replace_first(s: &mut String, from: &str, to: &str) -> bool {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 8) Return a sub-slice until first 0\n------------------------------------------------ */\npub fn until_zero(xs: &[i32]) -> &[i32] {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 9) Copy vs non-Copy: Point\n------------------------------------------------ */\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct Point {\n    pub x: i32,\n    pub y: i32,\n}\n\npub fn translate(p: Point, dx: i32, dy: i32) -> Point {\n    todo!()\n}\n\npub fn manhattan(a: Point, b: Point) -> u32 {\n    todo!()\n}\n\n/* ------------------------------------------------\nEX 10) Inventory (ownership + borrowing + Result)\nStore items by name in a Vec.\n------------------------------------------------ */\n#[derive(Debug, Default)]\npub struct Inventory {\n    items: Vec<Item>,\n}\n\n#[derive(Debug)]\nstruct Item {\n    name: String,\n    qty: u32,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum TakeError {\n    Missing,\n    NotEnough { available: u32 },\n}\n\nimpl Inventory {\n    pub fn new() -> Self {\n        Self { items: vec![] }\n    }\n\n    pub fn add(&mut self, name: &str, qty: u32) {\n        todo!()\n    }\n\n    pub fn take(&mut self, name: &str, qty: u32) -> Result<(), TakeError> {\n        todo!()\n    }\n\n    pub fn qty(&self, name: &str) -> Option<u32> {\n        todo!()\n    }\n}\n\n/* ------------------------------------------------\nEX 11) Deduplicate in place, keep order\nNote: simplest safe solution uses a HashSet<String> and clones for the "seen" set.\n(Still mutates the original vec in place by draining & rebuilding.)\n------------------------------------------------ */\npub fn dedup_keep_order(xs: &mut Vec<String>) {\n    todo!()\n}\n\n/* ============================================================\nTESTS\n============================================================ */\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ex1() {\n        assert_eq!(clamp_u8(-10), 0);\n        assert_eq!(clamp_u8(0), 0);\n        assert_eq!(clamp_u8(42), 42);\n        assert_eq!(clamp_u8(255), 255);\n        assert_eq!(clamp_u8(256), 255);\n        assert_eq!(clamp_u8(9999), 255);\n    }\n\n    #[test]\n    fn ex2() {\n        assert_eq!(adjacent_sums(&[]), vec![]);\n        assert_eq!(adjacent_sums(&[5]), vec![]);\n        assert_eq!(adjacent_sums(&[10, 20]), vec![30]);\n        assert_eq!(adjacent_sums(&[10, 20, 30]), vec![30, 50]);\n    }\n\n    #[test]\n    fn ex3() {\n        let a = Log::Info("hi".to_string());\n        let b = Log::Warn("careful".to_string());\n        let c = Log::Error {\n            code: 7,\n            msg: "bad".to_string(),\n        };\n\n        assert_eq!(format_log(&a), "[INFO] hi");\n        assert_eq!(format_log(&b), "[WARN] careful");\n        assert_eq!(format_log(&c), "[ERROR 7] bad");\n    }\n\n    #[test]\n    fn ex4() {\n        assert_eq!(first_word_longer_than("", 3), None);\n        assert_eq!(first_word_longer_than("a bb ccc", 3), None);\n        assert_eq!(first_word_longer_than("a bb cccc ddddd", 3), Some("cccc"));\n        assert_eq!(\n            first_word_longer_than("rust ownership rules", 6),\n            Some("ownership")\n        );\n    }\n\n    #[test]\n    fn ex5() {\n        assert_eq!(ex5_borrow_demo(), "pico!");\n    }\n\n    #[test]\n    fn ex6() {\n        assert_eq!(split_vec(vec![], 3), (vec![], vec![]));\n        assert_eq!(split_vec(vec![1, 2], 5), (vec![1, 2], vec![]));\n        assert_eq!(\n            split_vec(vec![1, 2, 3, 4, 5], 2),\n            (vec![1, 2], vec![3, 4, 5])\n        );\n        assert_eq!(\n            split_vec(vec![1, 2, 3, 4, 5], 0),\n            (vec![], vec![1, 2, 3, 4, 5])\n        );\n    }\n\n    #[test]\n    fn ex7() {\n        let mut s = "hello pico pico".to_string();\n        assert_eq!(replace_first(&mut s, "pico", "board"), true);\n        assert_eq!(s, "hello board pico");\n\n        assert_eq!(replace_first(&mut s, "missing", "x"), false);\n        assert_eq!(s, "hello board pico");\n\n        // edge case: empty "from" should do nothing in this worksheet\n        assert_eq!(replace_first(&mut s, "", "x"), false);\n    }\n\n    #[test]\n    fn ex8() {\n        assert_eq!(until_zero(&[]), &[]);\n        assert_eq!(until_zero(&[1, 2, 3]), &[1, 2, 3]);\n        assert_eq!(until_zero(&[1, 2, 0, 3, 4]), &[1, 2]);\n        assert_eq!(until_zero(&[0, 9, 9]), &[]);\n    }\n\n    #[test]\n    fn ex9() {\n        let p = Point { x: 10, y: -2 };\n        let q = translate(p, -3, 5);\n        // p is still usable because Point is Copy\n        assert_eq!(p, Point { x: 10, y: -2 });\n        assert_eq!(q, Point { x: 7, y: 3 });\n\n        assert_eq!(manhattan(p, q), 8);\n    }\n\n    #[test]\n    fn ex10() {\n        let mut inv = Inventory::new();\n\n        assert_eq!(inv.qty("bolt"), None);\n\n        inv.add("bolt", 10);\n        inv.add("nut", 3);\n        inv.add("bolt", 5);\n\n        assert_eq!(inv.qty("bolt"), Some(15));\n        assert_eq!(inv.qty("nut"), Some(3));\n\n        assert_eq!(inv.take("nut", 2), Ok(()));\n        assert_eq!(inv.qty("nut"), Some(1));\n\n        assert_eq!(\n            inv.take("nut", 5),\n            Err(TakeError::NotEnough { available: 1 })\n        );\n        assert_eq!(inv.take("missing", 1), Err(TakeError::Missing));\n    }\n\n    #[test]\n    fn ex11() {\n        let mut xs = vec![\n            "a".to_string(),\n            "b".to_string(),\n            "a".to_string(),\n            "c".to_string(),\n            "b".to_string(),\n        ];\n        dedup_keep_order(&mut xs);\n        assert_eq!(xs, vec!["a".to_string(), "b".to_string(), "c".to_string()]);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"bonus-at-home",children:"Bonus at home"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Rewrite the function at exercise 2 from previous lab, but this time implement it using the ",(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/sieve-of-eratosthenes/",children:"Sieve of Eratosthenes"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Define a struct called MiniTuring, with a buffer of 256 booleans and a cursor."}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Write an associated (static) function called new that creates an instance of the structure."}),"\n",(0,r.jsx)(n.li,{children:"Write a method called display that prints the tape with 1's and 0's instead of trues and falses, without newlines or spaces in between"}),"\n",(0,r.jsx)(n.li,{children:'Read the keyboard until "h" is received. "l" will move the cursor to the left with wrap around, "r" will move the cursor to the right with wrap around, "1" will set the element at the cursor to true, "0" will set the element at the cursor to false, "p" prints the value at cursor, "h" displays the tape'}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Create a basic expression parser for integer numbers, which supports +,-,*,/. Assume unary - will not happen (no expressions like 5*-3, -2+7)"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define an enum called Expression with the appropriate variants(hint: use ",(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/alloc/boxed/struct.Box.html",children:(0,r.jsx)(n.code,{children:"Box"})}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Create a function that returns an Expression based on a given string. Respect operator precedence rules"}),"\n",(0,r.jsx)(n.li,{children:"Creates a function that takes an Expression and evaluates it to an i32"}),"\n",(0,r.jsx)(n.li,{children:"Read an expression from stdin and print out the result"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);