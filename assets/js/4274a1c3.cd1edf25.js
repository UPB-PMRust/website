"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4580],{10716:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"tutorial/embassy/index","title":"Embassy-rs Setup","description":"How to install the prerequisites for embassy-rs","source":"@site/versioned_docs/version-fils_en/tutorial/embassy/index.md","sourceDirName":"tutorial/embassy","slug":"/tutorials/embassy","permalink":"/docs/fils_en/tutorials/embassy","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/tutorial/embassy/index.md","tags":[],"version":"fils_en","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"slug":"/tutorials/embassy","description":"How to install the prerequisites for embassy-rs"},"sidebar":"tutorialSidebar","previous":{"title":"Electronics","permalink":"/docs/fils_en/tutorial/electronics/"}}');var t=r(74848),i=r(28453),o=r(11470),a=r(19365);const l={sidebar_position:2,slug:"/tutorials/embassy",description:"How to install the prerequisites for embassy-rs"},d="Embassy-rs Setup",c={},h=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Rust Toolchain",id:"rust-toolchain",level:3},{value:"Linux",id:"linux",level:4},{value:"Windows",id:"windows",level:4},{value:"<code>elf2uf2-rs</code>",id:"elf2uf2-rs",level:3},{value:"<code>probe-rs</code>",id:"probe-rs",level:3},{value:"VSCode Extension (Optional)",id:"vscode-extension-optional",level:3},{value:"Flashing over USB",id:"flashing-over-usb",level:2},{value:"Compiling",id:"compiling",level:3},{value:"Flashing",id:"flashing",level:3},{value:"Debugging using Raspberry Pi Debug Probe",id:"debugging-using-raspberry-pi-debug-probe",level:2},{value:"Building your first Embassy-rs project",id:"building-your-first-embassy-rs-project",level:2},{value:"Creating your crate",id:"creating-your-crate",level:3},{value:"Crate settings",id:"crate-settings",level:3},{value:"No standard library",id:"no-standard-library",level:4},{value:"No <code>main</code> function",id:"no-main-function",level:4},{value:"Toolchain setting",id:"toolchain-setting",level:4},{value:"rust-toolchain.toml",id:"rust-toolchaintoml",level:5},{value:"Memory layout",id:"memory-layout",level:4},{value:"<code>memory.x</code>",id:"memoryx",level:5},{value:"<code>build.rs</code>",id:"buildrs",level:5},{value:"Adding the Dependencies",id:"adding-the-dependencies",level:4},{value:"<code>embassy-executor</code>",id:"embassy-executor",level:5},{value:"<code>embassy-time</code>",id:"embassy-time",level:5},{value:"<code>embassy-rp</code>",id:"embassy-rp",level:4},{value:"<code>embassy-usb-logger</code>",id:"embassy-usb-logger",level:4},{value:"<code>probe-panic</code>",id:"probe-panic",level:3},{value:"The code",id:"the-code",level:3},{value:"<code>main.rs</code>",id:"mainrs",level:4}];function u(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"embassy-rs-setup",children:"Embassy-rs Setup"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, we will cover the steps needed in order to be able to compile and flash Rust applications for ",(0,t.jsx)(n.strong,{children:"STM32U545"})," and ",(0,t.jsx)(n.strong,{children:"RP2"}),"s, the MCU (Microcontroller Unit) found in our ",(0,t.jsx)(n.strong,{children:"STM32 Nucleo-U545RE-Q"})," and ",(0,t.jsx)(n.strong,{children:"Raspberry Pi Pico"}),"s."]}),"\n","\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(n.h3,{id:"rust-toolchain",children:"Rust Toolchain"}),"\n",(0,t.jsx)(n.p,{children:"In order to install the tools needed to compile Rust code, follow the next steps, depending on your operating system."}),"\n",(0,t.jsx)(n.h4,{id:"linux",children:"Linux"}),"\n",(0,t.jsx)(n.p,{children:"Run the this command in terminal:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This downloads and runs ",(0,t.jsx)(n.code,{children:"rustup-init.sh"}),", which in turn downloads and runs the correct version of the ",(0,t.jsx)(n.code,{children:"rustup-init"})," executable for your platform."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{}),(0,t.jsxs)(n.p,{children:["Before installing elf2uf2-rs, you need to install  ",(0,t.jsx)(n.code,{children:"pkg-config"})," and ",(0,t.jsx)(n.code,{children:"libudev"}),". You can get it by running the following in your terminal."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"sudo apt-get install pkg-config libudev-dev\n"})})]}),"\n",(0,t.jsx)(n.h4,{id:"windows",children:"Windows"}),"\n",(0,t.jsx)(n.p,{children:"Download the respective executable:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe",children:"RUSTUP-INIT.exe - 64bit"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe",children:"RUSTUP-INIT.exe - 32bit"})}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["You may be prompted to install ",(0,t.jsx)(n.a,{href:"https://visualstudio.microsoft.com/visual-cpp-build-tools/",children:"Visual Studio C++ Build tools"}),". If so, follow the instructions from the previous link."]}),(0,t.jsxs)(n.p,{children:["Even if Visual Studio is already on your machine, ",(0,t.jsx)(n.code,{children:"rustup"})," will not verify if the required components are present. If you experience issues with the ",(0,t.jsx)(n.code,{children:"rustup"})," installation on Windows, please follow ",(0,t.jsx)(n.a,{href:"https://rust-lang.github.io/rustup/installation/windows-msvc.html#installing-only-the-required-components-optional",children:"these instructions"})," to manually add the missing components."]})]}),"\n",(0,t.jsxs)(n.p,{children:["The last step is to run ",(0,t.jsx)(n.code,{children:"rustup --version"})," in terminal. If everything went well, you should see an output similar to this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"rustup 1.26.0 (5af9b9484 2023-04-05)\ninfo: This is the version for the rustup toolchain manager, not the rustc compiler.\ninfo: The currently active `rustc` version is `rustc 1.76.0 (07dca489a 2024-02-04)`\n"})}),"\n",(0,t.jsx)(n.h3,{id:"elf2uf2-rs",children:(0,t.jsx)(n.code,{children:"elf2uf2-rs"})}),"\n",(0,t.jsx)(n.p,{children:"This tool is needed to be able to program the board over USB. In order to install it, run the following in your terminal:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo install elf2uf2-rs\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then, run ",(0,t.jsx)(n.code,{children:"elf2uf2-rs --help"}),". If it was correctly installed, you should see something similar to this in your terminal:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"Usage: elf2uf2-rs [OPTIONS] <INPUT> [OUTPUT]\n\nArguments:\n  <INPUT>   Input file\n  [OUTPUT]  Output file\n\nOptions:\n  -v, --verbose  Verbose\n  -d, --deploy   Deploy to any connected pico\n  -s, --serial   Connect to serial after deploy\n  -h, --help     Print help\n"})}),"\n",(0,t.jsx)(n.h3,{id:"probe-rs",children:(0,t.jsx)(n.code,{children:"probe-rs"})}),"\n",(0,t.jsx)(n.p,{children:"This tool is an embedded debugging and target interaction toolkit. It enables its user to program and debug microcontrollers via a debug probe."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo install probe-rs-tools --locked\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you are on ",(0,t.jsx)(n.strong,{children:"Linux"})," you will also need to add this ",(0,t.jsx)(n.a,{href:"https://probe.rs/files/69-probe-rs.rules",children:(0,t.jsx)(n.code,{children:"udev"})})," file in ",(0,t.jsx)(n.code,{children:"/etc/udev/rules.d"}),". Then, run:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"udevadm control --reload # to ensure the new rules are used.\n\nudevadm trigger # to ensure the new rules are applied to already added devices.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"vscode-extension-optional",children:"VSCode Extension (Optional)"}),"\n",(0,t.jsxs)(n.p,{children:["For a better experience, go ahead and install the ",(0,t.jsx)(n.strong,{children:"Debugger for probe-rs"})," extension in the Microsoft Extension Marketplace. This will make debugging the program running on the RP2040 as easy as debugging a Rust program running on your host machine."]}),"\n",(0,t.jsx)(n.h2,{id:"flashing-over-usb",children:"Flashing over USB"}),"\n",(0,t.jsx)(n.h3,{id:"compiling",children:"Compiling"}),"\n",(0,t.jsxs)(n.p,{children:["You will need to compile your executable specifically for the target chip. The ",(0,t.jsx)(n.strong,{children:"RP2040"})," is based on the ",(0,t.jsx)(n.strong,{children:"ARM Cortex\u2011M0+"})," architecture, while the ",(0,t.jsx)(n.strong,{children:"STM32U545"})," and ",(0,t.jsx)(n.strong,{children:"RP2350"})," are based on the more powerful ",(0,t.jsx)(n.strong,{children:"ARM Cortex\u2011M33"})," architecture. In each case, we will need to specify the correct target when compiling. We can do that in multiple ways:"]}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsxs)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["using a ",(0,t.jsx)(n.code,{children:".cargo/config.toml"})," file:"]}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "thumbv8m.main-none-eabihf"\n'})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"passing it as a parameter to Cargo:"}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo build --release --target thumbv8m.main-none-eabihf\n"})})]}),(0,t.jsxs)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["using a ",(0,t.jsx)(n.code,{children:".cargo/config.toml"})," file:"]}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "thumbv8m.main-none-eabihf"\n'})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"passing it as a parameter to Cargo:"}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo build --release --target thumbv8m.main-none-eabihf\n"})})]}),(0,t.jsxs)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["using a ",(0,t.jsx)(n.code,{children:".cargo/config.toml"})," file:"]}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "thumbv6m-none-eabi"\n'})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"passing it as a parameter to Cargo:"}),"\n"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo build --release --target thumbv6m-none-eabi\n"})})]})]}),"\n",(0,t.jsx)(n.h3,{id:"flashing",children:"Flashing"}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:(0,t.jsxs)(n.p,{children:["For the STM32U545, flashing is typically done through its built\u2011in ",(0,t.jsx)(n.strong,{children:"DFU (Device Firmware Upgrade) mode"})," or via a ",(0,t.jsx)(n.strong,{children:"debug probe"})," such as ST\u2011LINK. To enter DFU mode, you usually hold the ",(0,t.jsx)(n.strong,{children:"BOOT0"})," pin high while resetting the device, which makes it appear as a USB device to your PC. Once in this mode, you can flash new firmware without repeatedly plugging and unplugging the USB cable. Many development boards also include a reset button to simplify this process."]})}),(0,t.jsxs)(a.A,{value:"rp2350",label:"Raspberry Pi Pico",default:!0,children:[(0,t.jsxs)(n.p,{children:["To flash a program to the Raspberry Pi Pico via USB, it needs to be in ",(0,t.jsx)(n.em,{children:"USB mass storage device mode"}),". To put it in this mode, you need to ",(0,t.jsxs)(n.strong,{children:["hold the ",(0,t.jsx)(n.code,{children:"BOOTSEL"})," button down"]}),"  while connecting it to your PC. Connecting and disconnecting the USB can lead to the port getting damaged, so we conveniently attached a reset button on the breadboard included on the ",(0,t.jsx)(n.strong,{children:"Pico Explorer Base"}),". Now, to make it reflashable again, just press the two buttons simultaneously."]}),(0,t.jsxs)(n.p,{children:["After connecting the board to your PC and compiling the program, locate the binary in the ",(0,t.jsx)(n.code,{children:"target/thumbv6m-none-eabi/release/"})," folder then, run:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"elf2uf2-rs -d -s /path/to/your/binary\n"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"-d"})," to automatically deploy to a mounted pico"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"-s"})," to open the pico as a serial device after deploy and print serial output"]}),"\n"]}),(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["On ",(0,t.jsx)(n.code,{children:"Windows"}),", you may need to run this command in a terminal that has ",(0,t.jsx)(n.strong,{children:"Admin Privileges"}),"."]})})]})]}),"\n",(0,t.jsx)(n.h2,{id:"debugging-using-raspberry-pi-debug-probe",children:"Debugging using Raspberry Pi Debug Probe"}),"\n",(0,t.jsxs)(n.p,{children:["In order to be able to debug the program running on the board, we will need to connect the ",(0,t.jsx)(n.strong,{children:"Raspberry Pi Debug Probe"})," to our ",(0,t.jsx)(n.strong,{children:"Raspberry Pi Pico W"}),". Below, you have a picture of the debug kit provided:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Raspberry Pi Debug probe",src:r(86230).A+"",width:"4579",height:"2612"})}),"\n",(0,t.jsxs)(n.p,{children:["To connect them, we will use the ",(0,t.jsx)(n.strong,{children:"3-pin debug to 0.1-inch header (female)"})," cable. First, carefully insert the ",(0,t.jsx)(n.strong,{children:"3-pin debug"})," head in the ",(0,t.jsx)(n.strong,{children:"right side"})," connector. Then you will also need to connect it to the Raspberry Pi Pico W. You will find attached the pinout, take a closer look at the bottom of the image:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Raspberry Pi Pico W pinout",src:r(28443).A+"",width:"842",height:"595"})}),"\n",(0,t.jsx)(n.p,{children:"The connections must be:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Wire"}),(0,t.jsx)(n.th,{children:"Raspberry Pi Pico W"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"TX (Orange)"}),(0,t.jsx)(n.td,{children:"SWCLK"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"GND (Black)"}),(0,t.jsx)(n.td,{children:"GND"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"RX (Yellow)"}),(0,t.jsx)(n.td,{children:"SWDIO"})]})]})]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"Do not forget to connect both the Debug Probe and Pico to your PC."})}),"\n",(0,t.jsx)(n.p,{children:"Now, you can either debug using the command line by running:"}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"probe-rs run --chip STM32U545RETxQ path/to/your/binary\n"})})}),(0,t.jsx)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"probe-rs run --chip RP2350 path/to/your/binary\n"})})}),(0,t.jsx)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"probe-rs run --chip RP2040 path/to/your/binary\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["or you can use ",(0,t.jsx)(n.strong,{children:"Debug and Run"})," view in Visual Studio Code. You will need to modify the ",(0,t.jsx)(n.code,{children:"programBinary"})," path in the ",(0,t.jsx)(n.code,{children:".vscode/launch.json"})," config file to point to your binary file."]}),"\n",(0,t.jsx)(n.h2,{id:"building-your-first-embassy-rs-project",children:"Building your first Embassy-rs project"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we will briefly go over the steps you need to take in order to get your first project using ",(0,t.jsx)(n.strong,{children:"Rust"})," and ",(0,t.jsx)(n.strong,{children:"Embassy-rs"})," going."]}),"\n",(0,t.jsx)(n.h3,{id:"creating-your-crate",children:"Creating your crate"}),"\n",(0,t.jsx)(n.p,{children:"The first step is to create your cargo package by running the following command in your terminal:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo new --vcs none embassy\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--vcs none"})," because at the moment we do not want to use any code versioning (they are useful, but this is not the purpose of this tutorial)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"crate-settings",children:"Crate settings"}),"\n",(0,t.jsxs)(n.p,{children:["Because we are running in an embedded environment, our code needs to be ",(0,t.jsx)(n.em,{children:'"tailored"'})," specifically for the microcontroller we intend to use. In our case, it is the ",(0,t.jsx)(n.strong,{children:"STM32U545"})," and ",(0,t.jsx)(n.strong,{children:"RP2"}),"s, but these general steps apply for any chip, produced by any manufacturer."]}),"\n",(0,t.jsx)(n.h4,{id:"no-standard-library",children:"No standard library"}),"\n",(0,t.jsxs)(n.p,{children:["Due to the size constraints imposed on us (in our case, ",(0,t.jsx)(n.code,{children:"2MB"})," of flash memory), the standard library has to go. We specify that by adding the ",(0,t.jsx)(n.code,{children:"#![no_std]"})," attribute to the beginning of our ",(0,t.jsx)(n.code,{children:"src/mains.rs"})," file."]}),"\n",(0,t.jsxs)(n.h4,{id:"no-main-function",children:["No ",(0,t.jsx)(n.code,{children:"main"})," function"]}),"\n",(0,t.jsxs)(n.p,{children:["Because we are using the ",(0,t.jsx)(n.strong,{children:"Embassy-rs"})," framework, we want to let it take care of the entry point of our program (because it has to do some complex operations, like allocating the ",(0,t.jsx)(n.code,{children:"task-arena"})," and ",(0,t.jsx)(n.code,{children:"executor"})," structures). For the moment, all we will need to do is add the ",(0,t.jsx)(n.code,{children:"#![no_main]"})," attribute to ",(0,t.jsx)(n.code,{children:"src/main.rs"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"toolchain-setting",children:"Toolchain setting"}),"\n",(0,t.jsxs)(n.p,{children:["Our chip can be one of several Cortex\u2011M families, and we need to specify the correct target triple when compiling. The ",(0,t.jsx)(n.strong,{children:"RP2040"})," is a ",(0,t.jsx)(n.strong,{children:"Cortex\u2011M0+"})," that uses the ",(0,t.jsx)(n.strong,{children:"ThumbV6\u2011M"})," architecture, while the ",(0,t.jsx)(n.strong,{children:"Raspberry Pi Pico 2"})," and the ",(0,t.jsx)(n.strong,{children:"STM32U545"})," are both ",(0,t.jsx)(n.strong,{children:"Cortex\u2011M33"})," devices that use the ",(0,t.jsx)(n.strong,{children:"ThumbV8\u2011M.main"})," architecture. We will do that using a ",(0,t.jsx)(n.code,{children:"rust-toolchain.toml"})," file, as it allows us to also set the toolchain release channel we will use, and the components we require."]}),"\n",(0,t.jsx)(n.p,{children:"An example of such file is this:"}),"\n",(0,t.jsx)(n.h5,{id:"rust-toolchaintoml",children:"rust-toolchain.toml"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Toml",children:'# This file is used to specify the version of the Rust toolchain that \n# should be used for your project.\n\n[toolchain]\n# The release to be used.\nchannel = "1.90"\n# The targets for compilation that need to be added. This is used for \n# cross-compilation, as the executables we are producing need to be\n# run on our boards.\ntargets = ["thumbv6m-none-eabi", "thumbv8m.main-none-eabihf"]\n# The additional componets to be installed along the Rust toolchain\ncomponents = ["rust-src", "rustfmt", "llvm-tools", "clippy"]\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["We can use the same ",(0,t.jsx)(n.code,{children:"rust-toolchain.toml"})," file for both the ",(0,t.jsx)(n.strong,{children:"RP2350"})," and the ",(0,t.jsx)(n.strong,{children:"STM32U545"}),", we just need to make sure to add both  ",(0,t.jsx)(n.strong,{children:"target triples"}),". The RP2040 is a Cortex-M0+ that uses the ",(0,t.jsx)(n.code,{children:"thumbv6m-none-eabi"})," target while the RP2350 and STM32U545 are both Cortex\u2011M33 devices, so they use the ",(0,t.jsx)(n.code,{children:"thumbv8m.main-none-eabi"})," target."]})}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsxs)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q/Raspberry Pi Pico 2",default:!0,children:[(0,t.jsx)(n.p,{children:"Please make sure that you install the Rust ARMv8-M target (thumbv8m.main-none-eabihf)."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"rustup target add thumbv8m.main-none-eabihf\n"})}),(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You can skip this step when the target is defined in ",(0,t.jsx)(n.code,{children:"rust-toolchain.toml"}),"."]})})]}),(0,t.jsxs)(a.A,{value:"rp2350",label:"Raspberry Pi Pico",default:!0,children:[(0,t.jsx)(n.p,{children:"Please make sure that you install the Rust ARMv6-M target (thumbv6m-none-eabi)."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"rustup target add thumbv6m-none-eabi\n"})}),(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You can skip this step when the target is defined in ",(0,t.jsx)(n.code,{children:"rust-toolchain.toml"}),"."]})})]})]}),"\n",(0,t.jsx)(n.h4,{id:"memory-layout",children:"Memory layout"}),"\n",(0,t.jsxs)(n.p,{children:["We also need to take care of the memory layout of our program when writing code for a microcontroller. These can be found in the datasheet of all the microcontrollers. Bellow, you can find the memory layout for the ",(0,t.jsx)(n.strong,{children:"STM32U545"})," and ",(0,t.jsx)(n.strong,{children:"RP2"}),"s:"]}),"\n",(0,t.jsx)(n.h5,{id:"memoryx",children:(0,t.jsx)(n.code,{children:"memory.x"})}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsxs)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ld",children:"MEMORY\n{\n  /* On-chip Flash memory */\n  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K\n\n  /* On-chip SRAM (SRAM1+SRAM2+SRAM3 combined) */\n  RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 256K\n}\n"})}),(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You don\u2019t need to provide a ",(0,t.jsx)(n.code,{children:"memory.x"})," file when using ",(0,t.jsx)(n.strong,{children:"Embassy"}),",",(0,t.jsx)(n.br,{}),"\n","because the ",(0,t.jsx)(n.code,{children:"embassy-stm32"})," crate has a feature called ",(0,t.jsx)(n.code,{children:"memory-x"}),"\nthat already supplies the required linker script."]})})]}),(0,t.jsxs)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ld",children:"MEMORY {\n    /*\n     * The RP2350 has either external or internal flash.\n     *\n     * 2 MiB is a safe default here, although a Pico 2 has 4 MiB.\n     */\n    FLASH : ORIGIN = 0x10000000, LENGTH = 2048K\n    /*\n     * RAM consists of 8 banks, SRAM0-SRAM7, with a striped mapping.\n     * This is usually good for performance, as it distributes load on\n     * those banks evenly.\n     */\n    RAM : ORIGIN = 0x20000000, LENGTH = 512K\n    /*\n     * RAM banks 8 and 9 use a direct mapping. They can be used to have\n     * memory areas dedicated for some specific job, improving predictability\n     * of access times.\n     * Example: Separate stacks for core0 and core1.\n     */\n    SRAM4 : ORIGIN = 0x20080000, LENGTH = 4K\n    SRAM5 : ORIGIN = 0x20081000, LENGTH = 4K\n}\n\nSECTIONS {\n    /* ### Boot ROM info\n     *\n     * Goes after .vector_table, to keep it in the first 4K of flash\n     * where the Boot ROM (and picotool) can find it\n     */\n    .start_block : ALIGN(4)\n    {\n        __start_block_addr = .;\n        KEEP(*(.start_block));\n        KEEP(*(.boot_info));\n    } > FLASH\n\n} INSERT AFTER .vector_table;\n\n/* move .text to start /after/ the boot info */\n_stext = ADDR(.start_block) + SIZEOF(.start_block);\n\nSECTIONS {\n    /* ### Picotool 'Binary Info' Entries\n     *\n     * Picotool looks through this block (as we have pointers to it in our\n     * header) to find interesting information.\n     */\n    .bi_entries : ALIGN(4)\n    {\n        /* We put this in the header */\n        __bi_entries_start = .;\n        /* Here are the entries */\n        KEEP(*(.bi_entries));\n        /* Keep this block a nice round size */\n        . = ALIGN(4);\n        /* We put this in the header */\n        __bi_entries_end = .;\n    } > FLASH\n} INSERT AFTER .text;\n\nSECTIONS {\n    /* ### Boot ROM extra info\n     *\n     * Goes after everything in our program, so it can contain a signature.\n     */\n    .end_block : ALIGN(4)\n    {\n        __end_block_addr = .;\n        KEEP(*(.end_block));\n    } > FLASH\n\n} INSERT AFTER .uninit;\n\nPROVIDE(start_to_end = __end_block_addr - __start_block_addr);\nPROVIDE(end_to_start = __start_block_addr - __end_block_addr);\n"})}),(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You don\u2019t need to provide a ",(0,t.jsx)(n.code,{children:"memory.x"})," file when using ",(0,t.jsx)(n.strong,{children:"Embassy"}),",",(0,t.jsx)(n.br,{}),"\n","because the ",(0,t.jsx)(n.code,{children:"embassy-rp"})," crate has a feature called ",(0,t.jsx)(n.code,{children:"memory-x"}),"\nthat already supplies the required linker script."]})})]}),(0,t.jsxs)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ld",children:"MEMORY {\n    BOOT2 : ORIGIN = 0x10000000, LENGTH = 0x100\n    /*\n     * Here we assume you have 2048 KiB of Flash. This is what the Pi Pico\n     * has, but your board may have more or less Flash and you should adjust\n     * this value to suit.\n     */\n    FLASH : ORIGIN = 0x10000100, LENGTH = 2048K - 0x100\n    /*\n     * RAM consists of 4 banks, SRAM0-SRAM3, with a striped mapping.\n     * This is usually good for performance, as it distributes load on\n     * those banks evenly.\n     */\n    RAM : ORIGIN = 0x20000000, LENGTH = 256K\n    /*\n     * RAM banks 4 and 5 use a direct mapping. They can be used to have\n     * memory areas dedicated for some specific job, improving predictability\n     * of access times.\n     * Example: Separate stacks for core0 and core1.\n     */\n    SRAM4 : ORIGIN = 0x20040000, LENGTH = 4k\n    SRAM5 : ORIGIN = 0x20041000, LENGTH = 4k\n\n    /* SRAM banks 0-3 can also be accessed directly. However, those ranges\n       alias with the RAM mapping, above. So don't use them at the same time!\n    SRAM0 : ORIGIN = 0x21000000, LENGTH = 64k\n    SRAM1 : ORIGIN = 0x21010000, LENGTH = 64k\n    SRAM2 : ORIGIN = 0x21020000, LENGTH = 64k\n    SRAM3 : ORIGIN = 0x21030000, LENGTH = 64k\n    */\n}\n\nEXTERN(BOOT2_FIRMWARE)\n\nSECTIONS {\n    /* ### Boot loader\n     *\n     * An executable block of code which sets up the QSPI interface for\n     * 'Execute-In-Place' (or XIP) mode. Also sends chip-specific commands to\n     * the external flash chip.\n     *\n     * Must go at the start of external flash, where the Boot ROM expects it.\n     */\n    .boot2 ORIGIN(BOOT2) :\n    {\n        KEEP(*(.boot2));\n    } > BOOT2\n} INSERT BEFORE .text;\n\nSECTIONS {\n    /* ### Boot ROM info\n     *\n     * Goes after .vector_table, to keep it in the first 512 bytes of flash,\n     * where picotool can find it\n     */\n    .boot_info : ALIGN(4)\n    {\n        KEEP(*(.boot_info));\n    } > FLASH\n\n} INSERT AFTER .vector_table;\n\n/* move .text to start /after/ the boot info */\n_stext = ADDR(.boot_info) + SIZEOF(.boot_info);\n\nSECTIONS {\n    /* ### Picotool 'Binary Info' Entries\n     *\n     * Picotool looks through this block (as we have pointers to it in our\n     * header) to find interesting information.\n     */\n    .bi_entries : ALIGN(4)\n    {\n        /* We put this in the header */\n        __bi_entries_start = .;\n        /* Here are the entries */\n        KEEP(*(.bi_entries));\n        /* Keep this block a nice round size */\n        . = ALIGN(4);\n        /* We put this in the header */\n        __bi_entries_end = .;\n    } > FLASH\n} INSERT AFTER .text;\n"})}),(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You don\u2019t need to provide a ",(0,t.jsx)(n.code,{children:"memory.x"})," file when using ",(0,t.jsx)(n.strong,{children:"Embassy"}),",",(0,t.jsx)(n.br,{}),"\n","because the ",(0,t.jsx)(n.code,{children:"embassy-rp"})," crate has a feature called ",(0,t.jsx)(n.code,{children:"memory-x"}),"\nthat already supplies the required linker script."]})})]})]}),"\n",(0,t.jsxs)(n.p,{children:["To use the ",(0,t.jsx)(n.code,{children:"memory.x"})," layout file, we will also need to use a build script. Rust facilitates that through the ",(0,t.jsx)(n.code,{children:"build.rs"})," file. Bellow you will find an explained build script you can use."]}),"\n",(0,t.jsx)(n.h5,{id:"buildrs",children:(0,t.jsx)(n.code,{children:"build.rs"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'//! This build script copies the `memory.x` file from the crate root into\n//! a directory where the linker can always find it at build time.\n//! For many projects this is optional, as the linker always searches the\n//! project root directory -- wherever `Cargo.toml` is. However, if you\n//! are using a workspace or have a more complicated build setup, this\n//! build script becomes required. Additionally, by requesting that\n//! Cargo re-run the build script whenever `memory.x` is changed,\n//! updating `memory.x` ensures a rebuild of the application with the\n//! new memory settings.\n\nuse std::env;\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::PathBuf;\n\nfn main() {\n    // Put `memory.x` in our output directory and ensure it\'s\n    // on the linker search path.\n    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());\n    File::create(out.join("memory.x"))\n        .unwrap()\n        .write_all(include_bytes!("./memory.x"))\n        .unwrap();\n    println!("cargo:rustc-link-search={}", out.display());\n    println!("cargo:rerun-if-changed={{layout}}");\n\n    // `--nmagic` is required if memory section addresses are not aligned to 0x10000,\n    // for example the FLASH and RAM sections in your `memory.x`.\n    println!("cargo:rustc-link-arg=--nmagic");\n\n    // The `link.x` linker script provided by `cortex_m_rt` (minimal runtime for\n    // Cortex-M microcontrollers used by embassy) will include our `memory.x` memory layout.\n    println!("cargo:rustc-link-arg=-Tlink.x");\n\n    // The `link-rp.x` linker script provided by `embassy_rp` that defines the\n    // BOOT2 section.\n    println!("cargo:rustc-link-arg-bins=-Tlink-rp.x");\n\n    // The `defmt.x` linker script provided by `defmt`.\n    println!("cargo:rustc-link-arg-bins=-Tdefmt.x");\n}\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["If you are using the ",(0,t.jsx)(n.code,{children:"memory.x"})," provided by ",(0,t.jsx)(n.code,{children:"embassy-rs"})," comment this part:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());\n    File::create(out.join("memory.x"))\n        .unwrap()\n        .write_all(include_bytes!("./memory.x"))\n        .unwrap();\n    println!("cargo:rustc-link-search={}", out.display());\n    println!("cargo:rerun-if-changed={{layout}}");\n'})})]}),"\n",(0,t.jsx)(n.h4,{id:"adding-the-dependencies",children:"Adding the Dependencies"}),"\n",(0,t.jsxs)(n.p,{children:["At this step, we must add the dependencies we will use for our project. Bellow you will find the basics you will need for a minimal application, including an ",(0,t.jsx)(n.code,{children:"usb_logger"})," to ",(0,t.jsx)(n.em,{children:'"enable"'})," debugging over serial."]}),"\n",(0,t.jsx)(n.h5,{id:"embassy-executor",children:(0,t.jsx)(n.code,{children:"embassy-executor"})}),"\n",(0,t.jsxs)(n.p,{children:["This is an ",(0,t.jsx)(n.code,{children:"async/await"})," executor designed for embedded. To add it as a dependency to your project, run:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-executor --features arch-cortex-m,executor-thread,executor-interrupt,integrated-timers,task-arena-size-32768\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"arch-cortex-m"})," - feature to specify we are running on the cortex M architecture"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"executor-thread"})," - enable the thread-mode executor (using WFE/SEV in Cortex-M, WFI in other embedded archs)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"executor-interrupt"})," - enable the interrupt-mode executor (available in Cortex-M only)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"integrated-timers"})," - use the executor-integrated embassy-time timer queue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"task-arena-size-X"})," - sets the task arena size"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We will also need to add the ",(0,t.jsx)(n.code,{children:"cortex-m"})," and ",(0,t.jsx)(n.code,{children:"cortex-m-rt"})," crates as dependencies, as the ",(0,t.jsx)(n.code,{children:"#[executor::main]"})," attribute depends on the minimal startup code for the Cortex M microcontrollers found in this crates. To do that, run:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add cortex-m\ncargo add cortex-m-rt\n"})}),"\n",(0,t.jsx)(n.h5,{id:"embassy-time",children:(0,t.jsx)(n.code,{children:"embassy-time"})}),"\n",(0,t.jsx)(n.p,{children:"This crate enables timekeeping, timeouts and delays. Add it by running:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-time\n"})}),"\n",(0,t.jsx)(n.h4,{id:"embassy-rp",children:(0,t.jsx)(n.code,{children:"embassy-rp"})}),"\n",(0,t.jsxs)(n.p,{children:["This crate is a ",(0,t.jsx)(n.strong,{children:"Hardware Abstraction Layer"})," for the ",(0,t.jsx)(n.strong,{children:"RP2040"}),". You can add it to your project like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-rp --features time-driver,critical-section-impl\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"time-driver"})," - enable the timer for use with ",(0,t.jsx)(n.code,{children:"embassy-time"})," with a ",(0,t.jsx)(n.code,{children:"1MHz"})," tick rate."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"critical-section-impl"})," - configure the critical section crate to use an implementation that is safe for multicore use on RP2040"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"embassy-usb-logger",children:(0,t.jsx)(n.code,{children:"embassy-usb-logger"})}),"\n",(0,t.jsxs)(n.p,{children:["USB implementation of the ",(0,t.jsx)(n.code,{children:"log"})," crate. It allows the usage of ",(0,t.jsx)(n.code,{children:"info!"})," macro and some more. To add it, run the following command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add log\ncargo add embassy-usb-logger\n"})}),"\n",(0,t.jsx)(n.h3,{id:"probe-panic",children:(0,t.jsx)(n.code,{children:"probe-panic"})}),"\n",(0,t.jsxs)(n.p,{children:["This crate adds a panic handler for the microchip that prints panic messages over ",(0,t.jsx)(n.strong,{children:"JTAG"}),", and in order to add it, run:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cargo add panic-probe\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-code",children:"The code"}),"\n",(0,t.jsxs)(n.p,{children:["Here you can find a minimally explained code that prints ",(0,t.jsx)(n.code,{children:'"Hello World!"'})," over the serial interface:"]}),"\n",(0,t.jsx)(n.h4,{id:"mainrs",children:(0,t.jsx)(n.code,{children:"main.rs"})}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(a.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse defmt::info;\nuse embassy_executor::Spawner;\nuse embassy_stm32::{self as _, Config};\n\nuse defmt_rtt as _;\nuse embassy_time::Timer;\nuse panic_probe as _;\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let config = Config::default();\n    let _peripherals = embassy_stm32::init(config);\n    loop {\n        info!("Hello, World!");\n        Timer::after_secs(1).await;\n    }\n}\n'})})}),(0,t.jsx)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse embassy_executor::Spawner;\nuse embassy_rp::bind_interrupts;\nuse embassy_rp::peripherals::USB;\nuse embassy_rp::usb::{Driver, InterruptHandler as UsbInterruptHandler};\nuse embassy_time::Timer;\nuse log::info;\nuse panic_probe as _;\n\n// Bind interrupts to their handlers.\nbind_interrupts!(struct Irqs {\n    USBCTRL_IRQ => UsbInterruptHandler<USB>;\n});\n\n// Async task for USB logging.\n#[embassy_executor::task]\nasync fn logger_task(driver: Driver<\'static, USB>) {\n    embassy_usb_logger::run!(1024, log::LevelFilter::Info, driver);\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    // Initialize peripherals and USB driver.\n    let rp_peripherals = embassy_rp::init(Default::default());\n    let usb_driver = Driver::new(rp_peripherals.USB, Irqs);\n\n    // Spawn the logger task\n    spawner.spawn(logger_task(usb_driver)).unwrap();\n    \n    Timer::after_millis(1000).await;\n    info!("Hello, world!");\n\n    loop {\n        Timer::after_millis(10).await;\n    }\n}\n'})})})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},19365:(e,n,r)=>{r.d(n,{A:()=>o});r(96540);var s=r(34164);const t={tabItem:"tabItem_Ymn6"};var i=r(74848);function o({children:e,hidden:n,className:r}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(t.tabItem,r),hidden:n,children:e})}},11470:(e,n,r)=>{r.d(n,{A:()=>T});var s=r(96540),t=r(34164),i=r(17559),o=r(23104),a=r(56347),l=r(205),d=r(57485),c=r(31682),h=r(70679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:r}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((({props:{value:e,label:n,attributes:r,default:s}})=>({value:e,label:n,attributes:r,default:s})))}(r);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function m({value:e,tabValues:n}){return n.some((n=>n.value===e))}function x({queryString:e=!1,groupId:n}){const r=(0,a.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(t),(0,s.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})}),[t,r])]}function b(e){const{defaultValue:n,queryString:r=!1,groupId:t}=e,i=p(e),[o,a]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[d,c]=x({queryString:r,groupId:t}),[u,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,t]=(0,h.Dv)(n);return[r,(0,s.useCallback)((e=>{n&&t.set(e)}),[n,t])]}({groupId:t}),g=(()=>{const e=d??u;return m({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{g&&a(g)}),[g]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);a(e),c(e),b(e)}),[c,b,i]),tabValues:i}}var g=r(92303);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=r(74848);function y({className:e,block:n,selectedValue:r,selectValue:s,tabValues:i}){const a=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),d=e=>{const n=e.currentTarget,t=a.indexOf(n),o=i[t].value;o!==r&&(l(n),s(o))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=a.indexOf(e.currentTarget)+1;n=a[r]??a[0];break}case"ArrowLeft":{const r=a.indexOf(e.currentTarget)-1;n=a[r]??a[a.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:i.map((({value:e,label:n,attributes:s})=>(0,f.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{a.push(e)},onKeyDown:c,onClick:d,...s,className:(0,t.A)("tabs__item",j.tabItem,s?.className,{"tabs__item--active":r===e}),children:n??e},e)))})}function v({lazy:e,children:n,selectedValue:r}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function w(e){const n=b(e);return(0,f.jsxs)("div",{className:(0,t.A)(i.G.tabs.container,"tabs-container",j.tabList),children:[(0,f.jsx)(y,{...n,...e}),(0,f.jsx)(v,{...n,...e})]})}function T(e){const n=(0,g.A)();return(0,f.jsx)(w,{...e,children:u(e.children)},String(n))}},28443:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/picow-pinout-53d738f9b62492655771d028c1a11829.svg"},86230:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/the-probe-f15ab4734e339bf07b3daafcf3005f0d.png"},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(96540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);