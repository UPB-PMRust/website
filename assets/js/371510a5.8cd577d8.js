"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9586],{37014:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"project/2025/eduard.balaceanu/index","title":"Matrix LED Adaptive Headlight System","description":"A simplified replica of modern adaptive headlight systems found in vehicles, using a matrix of LEDs, real-time sensor input, and Rust-powered control logic running on a Raspberry Pi Pico 2W.","source":"@site/versioned_docs/version-fils_en/project/2025/eduard.balaceanu/index.md","sourceDirName":"project/2025/eduard.balaceanu","slug":"/project/2025/eduard.balaceanu/","permalink":"/docs/fils_en/project/2025/eduard.balaceanu/","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/versioned_docs/version-fils_en/project/2025/eduard.balaceanu/index.md","tags":[],"version":"fils_en","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Remote-controlled car with LiDAR","permalink":"/docs/fils_en/project/2025/dragos_rascanu.Trolom/"},"next":{"title":"Turret with object identification","permalink":"/docs/fils_en/project/2025/eduard.purcarescu/"}}');var s=i(74848),r=i(28453);const d={},o="Matrix LED Adaptive Headlight System",a={},l=[{value:"Description",id:"description",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Diagram",id:"diagram",level:2},{value:"Weekly Log",id:"weekly-log",level:2},{value:"Week 8 \u2013 May 4th",id:"week-8--may-4th",level:3},{value:"Week 9 \u2013 May 11",id:"week-9--may-11",level:3},{value:"Week 10 \u2013 May 18",id:"week-10--may-18",level:3},{value:"Week 11 \u2013 May 25",id:"week-11--may-25",level:3},{value:"Hardware Design",id:"hardware-design",level:2},{value:"\ud83d\udcf8 Photos of the Build",id:"-photos-of-the-build",level:3},{value:"KiCad Schematic",id:"kicad-schematic",level:4},{value:"Bill of Materials",id:"bill-of-materials",level:2},{value:"Software",id:"software",level:2}];function c(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"matrix-led-adaptive-headlight-system",children:"Matrix LED Adaptive Headlight System"})}),"\n",(0,s.jsx)(t.p,{children:"A simplified replica of modern adaptive headlight systems found in vehicles, using a matrix of LEDs, real-time sensor input, and Rust-powered control logic running on a Raspberry Pi Pico 2W."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Author:"})," Eduard-Andrei Balaceanu ",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.strong,{children:"GitHub Project Link:"}),": ",(0,s.jsx)(t.a,{href:"https://github.com/UPB-PMRust-Students/project-eduard1506",children:"https://github.com/UPB-PMRust-Students/project-eduard1506"})]})}),"\n",(0,s.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(t.p,{children:"This project showcases the knowledge acquired throughout the semester by designing a functional hardware system that runs software written entirely in Rust. The system replicates a simplified version of the adaptive headlight functionality found in modern vehicles, using a matrix of LEDs controlled by a Raspberry Pi Pico 2W microcontroller."}),"\n",(0,s.jsx)(t.p,{children:"The setup includes multiple white LEDs arranged in a grid, which dynamically turn on/off or dim based on real-time sensor input. The system uses light sensors to detect the presence and direction of oncoming lights, and a distance sensor to identify nearby objects. It also features adaptive cornering simulation using a joystick input."}),"\n",(0,s.jsx)(t.p,{children:"The goal is to demonstrate real-time hardware control, sensor input interpretation, and modular embedded design using the Rust programming language."}),"\n",(0,s.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(t.p,{children:"One of my biggest passions is cars\u2014and everything they represent. I've always loved the feeling of a late-night drive, but to truly enjoy it, you need a powerful and intelligent lighting system. Matrix LED headlights represent the pinnacle of automotive lighting technology, adapting dynamically to changing road conditions, light sources, and traffic."}),"\n",(0,s.jsx)(t.p,{children:"I\u2019ve been fascinated by how this system works, how it improves both safety and comfort, and why it isn\u2019t more widely adopted across all types of vehicles. Through this project, I wanted to explore the core principles behind adaptive lighting and bring a simplified version to life using accessible components and Rust-based control logic."}),"\n",(0,s.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(t.p,{children:"The system architecture consists of the following functional layers:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Sensor Layer"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Three ambient light sensors (TEMT6000) detect the direction and intensity of incoming light sources."}),"\n",(0,s.jsx)(t.li,{children:"One ultrasonic sensor (HC-SR04) measures the distance to nearby objects."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Control Layer"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A Raspberry Pi Pico 2W reads input data from all sensors."}),"\n",(0,s.jsx)(t.li,{children:"A custom control algorithm written in Rust determines which LEDs should be turned on, off, or dimmed."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Output Layer"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A matrix of white LEDs is powered and controlled via IRLZ44N MOSFETs."}),"\n",(0,s.jsx)(t.li,{children:"The system dims or disables individual LEDs based on sensor input to avoid blinding oncoming traffic while preserving road visibility."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Each component is connected using breadboards and jumper wires, with careful power and grounding design to ensure stability. The entire system operates without external Wi-Fi or cloud dependency, functioning in a fully local, embedded environment."}),"\n",(0,s.jsx)(t.h2,{id:"diagram",children:"Diagram"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"alt text",src:i(56673).A+""})}),"\n",(0,s.jsx)(t.h2,{id:"weekly-log",children:"Weekly Log"}),"\n",(0,s.jsx)(t.h3,{id:"week-8--may-4th",children:"Week 8 \u2013 May 4th"}),"\n",(0,s.jsx)(t.p,{children:"Over the past few weeks, I\u2019ve been gathering all the necessary components for the project. After pitching my idea to the professor and getting the green light, I decided to attempt building a simplified version of the Matrix LED adaptive headlight system used in modern vehicles."}),"\n",(0,s.jsx)(t.p,{children:"This week marked the official start of the documentation process. I\u2019ve already experimented with wiring the Pico 2W, tested the debugger, and ran a few simple LED blink tests in Rust to confirm everything\u2019s working. Most of the hardware is now in place \u2014 the MOSFETs, LEDs, sensors, and breadboards \u2014 though I\u2019m still waiting on the OLED screen and joystick module."}),"\n",(0,s.jsx)(t.p,{children:"I also started working on the architecture diagram using diagrams.net. I\u2019m aiming to create something clean and professional, so the structure makes sense both visually and logically. Once that\u2019s done, I\u2019ll export it and integrate it into the site. Documentation is coming together nicely so far."}),"\n",(0,s.jsx)(t.h3,{id:"week-9--may-11",children:"Week 9 \u2013 May 11"}),"\n",(0,s.jsx)(t.p,{children:"Building the physical matrix was the main focus this week. I wired the 6\xd73 LED grid on the breadboards and connected the column MOSFET gates to the Pico\u2019s GPIO 7 through 12. The row anode lines were wired to GPIO 13 through 15, each protected by a 330\u03a9 resistor to limit current. After checking the wiring multiple times, I was able to confirm that I could control each LED individually and that the matrix multiplexing logic worked as planned."}),"\n",(0,s.jsx)(t.h3,{id:"week-10--may-18",children:"Week 10 \u2013 May 18"}),"\n",(0,s.jsx)(t.p,{children:"Sensor integration was the big challenge for this week. I connected two TEMT6000 light sensors, one on each side of the matrix, to serve as left/right ambient detectors. Both sensors were connected to Pico ADC pins (GP16 and GP17), and I wrote the initial Rust code to read and process their analog output. I also integrated the HC-SR04 ultrasonic distance sensor, adding a simple voltage divider on the ECHO pin to safely handle the 5V signal. There were some early issues with sensor noise and ADC instability, but after a few tweaks to the software and power supply setup, the sensor readings became reliable."}),"\n",(0,s.jsx)(t.h3,{id:"week-11--may-25",children:"Week 11 \u2013 May 25"}),"\n",(0,s.jsx)(t.p,{children:"This week was all about refining the software. I finished the main matrix control algorithm in Rust, implementing column-based multiplexing and software PWM for smooth row dimming. After some trial and error, I managed to significantly reduce LED flicker by increasing the PWM steps and optimizing the timing of the multiplex loop. I also improved the sensor code by reading the ultrasonic sensor less frequently (to avoid blocking LED refresh) and adding a smoothing function to the global brightness value, which eliminated any visible jitter in the LEDs. By the end of the week, the system reliably adapted the LED matrix in real time based on both ambient light and object distance, running smoothly and consistently."}),"\n",(0,s.jsx)(t.h2,{id:"hardware-design",children:"Hardware Design"}),"\n",(0,s.jsx)(t.p,{children:"The core of the system is built around a Raspberry Pi Pico 2W, which interfaces with a 6\xd73 matrix of white LEDs. These LEDs are arranged in 6 columns and 3 rows and are controlled through IRLZ44N N-channel MOSFETs. Each column has a dedicated MOSFET that connects the cathodes of the LEDs in that column to ground, while the rows are powered individually using GPIO pins through 330\u03a9 resistors. This allows matrix-style multiplexing, which significantly reduces the number of GPIOs required to control multiple LEDs individually."}),"\n",(0,s.jsx)(t.p,{children:"The full assembly is split across two breadboards:"}),"\n",(0,s.jsx)(t.p,{children:"One holds the Pico microcontroller, all necessary resistors, and distributes row power rails"}),"\n",(0,s.jsx)(t.p,{children:"The second contains all MOSFETs, the LEDs, and the column control wiring"}),"\n",(0,s.jsx)(t.p,{children:"In addition to the LED control, the hardware integrates multiple sensors:"}),"\n",(0,s.jsx)(t.p,{children:"Two TEMT6000 light sensors, used to detect ambient brightness from both sides"}),"\n",(0,s.jsx)(t.p,{children:"One HC-SR04 ultrasonic distance sensor, used to measure object proximity"}),"\n",(0,s.jsx)(t.p,{children:"(Planned) A joystick for manual steering simulation"}),"\n",(0,s.jsx)(t.p,{children:"All sensors are powered by the Pico and are connected to its GPIOs as shown below."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Pico GPIO Pin"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Function"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Connected To"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP17"}),(0,s.jsx)(t.td,{children:"TRIG signal for ultrasonic sensor"}),(0,s.jsx)(t.td,{children:"HC-SR04 pin 3 (TRIG)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP16"}),(0,s.jsx)(t.td,{children:"ECHO signal input (via voltage divider)"}),(0,s.jsx)(t.td,{children:"HC-SR04 pin 4 (ECHO)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP7"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 1"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 1 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP8"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 2"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 2 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP9"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 3"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 3 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP10"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 4"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 4 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP11"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 5"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 5 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP12"}),(0,s.jsx)(t.td,{children:"MOSFET Gate for Column 6"}),(0,s.jsx)(t.td,{children:"Gate of MOSFET 6 (via 220\u03a9 resistor)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP13"}),(0,s.jsx)(t.td,{children:"LED Matrix Row 1 (Anode supply)"}),(0,s.jsx)(t.td,{children:"Row 1 LEDs via 330\u03a9 resistor"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP14"}),(0,s.jsx)(t.td,{children:"LED Matrix Row 2"}),(0,s.jsx)(t.td,{children:"Row 2 LEDs via 330\u03a9 resistor"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP15"}),(0,s.jsx)(t.td,{children:"LED Matrix Row 3"}),(0,s.jsx)(t.td,{children:"Row 3 LEDs via 330\u03a9 resistor"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP26"}),(0,s.jsx)(t.td,{children:"Light Sensor 1 (left side)"}),(0,s.jsx)(t.td,{children:"Analog OUT (V pin) of TEMT6000 #1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"GP17"}),(0,s.jsx)(t.td,{children:"Light Sensor 2 (right side)"}),(0,s.jsx)(t.td,{children:"Analog OUT (V pin) of TEMT6000 #2"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Sensor Wiring\nTEMT6000 Ambient Light Sensors (x2)\nThe project uses two TEMT6000 ambient light sensors, placed on opposite sides of the breadboard to detect directional brightness \u2014 simulating oncoming traffic from the left or right. These sensors output an analog voltage that varies with light intensity, allowing the Pico to react accordingly."}),"\n",(0,s.jsx)(t.p,{children:"Each sensor has three pins:\nS (Supply): Connected directly to the Pico\u2019s 3.3V output pin\nG (Ground): Connected to the common GND rail shared across the circuit\nV (Analog output): Connected to an ADC-capable GPIO on the Pico"}),"\n",(0,s.jsx)(t.p,{children:"HC-SR04 Ultrasonic Distance Sensor\nThe HC-SR04 module is used to detect obstacles in front of the LED array, simulating real-time responsiveness to nearby objects or vehicles. It has four pins:\nVCC: Connected to 5V (VSYS) from the Pico\nGND: Connected to the common ground rail\nTRIG: Connected to GP2, configured as an output\nECHO: Connected to GP3, configured as an input, with a voltage divider"}),"\n",(0,s.jsx)(t.p,{children:"The ECHO pin outputs 5V, which is unsafe for direct connection to the Pico\u2019s 3.3V GPIOs. To protect the microcontroller, a simple resistive voltage divider is used:\nA 10k\u03a9 resistor connects ECHO to GP3\nA 22k\u03a9 resistor connects the midpoint between ECHO and GP3 to GND\nThis reduces the 5V ECHO pulse to ~3.3V, making it safe for the RP2040 input."}),"\n",(0,s.jsx)(t.h3,{id:"-photos-of-the-build",children:"\ud83d\udcf8 Photos of the Build"}),"\n",(0,s.jsx)(t.p,{children:"The following images show the current stage of hardware assembly, including breadboard layout, wiring details, and sensor positioning."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"alt text",src:i(20098).A+"",width:"1024",height:"768"}),"\n",(0,s.jsx)(t.img,{alt:"alt text",src:i(43661).A+"",width:"1024",height:"768"})]}),"\n",(0,s.jsx)(t.h4,{id:"kicad-schematic",children:"KiCad Schematic"}),"\n",(0,s.jsx)("img",{src:"ProiectMicroprocesoare.svg",alt:"Full Setup",width:"500"}),"\n",(0,s.jsx)(t.h2,{id:"bill-of-materials",children:"Bill of Materials"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Device"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Usage"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Price"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Raspberry Pi Pico W"}),(0,s.jsx)(t.td,{children:"The microcontroller"}),(0,s.jsx)(t.td,{children:"35 RON"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Breadboard"}),(0,s.jsx)(t.td,{children:"The main breadboard"}),(0,s.jsx)(t.td,{children:"10 RON"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Light Sensors (x2)"}),(0,s.jsx)(t.td,{children:"Measure ambient light"}),(0,s.jsx)(t.td,{children:"2 x 9.99 RON"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Ultrasonic Sensor"}),(0,s.jsx)(t.td,{children:"Detect object distance"}),(0,s.jsx)(t.td,{children:"6.49 RON"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"MOSFETs (IRLZ44N x6)"}),(0,s.jsx)(t.td,{children:"Drive high-power LEDs"}),(0,s.jsx)(t.td,{children:"6 x 4.99 RON"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"LED Assortment"}),(0,s.jsx)(t.td,{children:"Visual output (matrix lighting)"}),(0,s.jsx)(t.td,{children:"26.99 RON"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"software",children:"Software"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Library"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Description"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Usage"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"heapless"})}),(0,s.jsx)(t.td,{children:"Data structure library"}),(0,s.jsx)(t.td,{children:"Used for String vectors"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"embassy_rp"})}),(0,s.jsx)(t.td,{children:"Embassy HAL for the Raspberry Pi RP2040"}),(0,s.jsx)(t.td,{children:"Used to program the Pico"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"embassy_sync"})}),(0,s.jsx)(t.td,{children:"Sync primitives and async data support"}),(0,s.jsx)(t.td,{children:"Communicating through tasks"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"embedded-hal"})}),(0,s.jsx)(t.td,{children:"Hardware abstraction traits"}),(0,s.jsx)(t.td,{children:"Common interface for embedded peripherals"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"defmt"}),", ",(0,s.jsx)(t.code,{children:"defmt-rtt"})]}),(0,s.jsx)(t.td,{children:"Lightweight logging + RTT interface"}),(0,s.jsx)(t.td,{children:"Debugging via the probe"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"cortex-m"})}),(0,s.jsx)(t.td,{children:"ARM Cortex-M microcontroller support"}),(0,s.jsx)(t.td,{children:"Low-level control"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"cortex-m-rt"})}),(0,s.jsx)(t.td,{children:"Runtime support"}),(0,s.jsx)(t.td,{children:"Startup and interrupts"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"panic-halt"})}),(0,s.jsx)(t.td,{children:"Panic behavior"}),(0,s.jsx)(t.td,{children:"Safe stop on crash"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},56673:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/MatrixLED-2da01c85a90e731553cc2eb66a8ffe4a.svg"},20098:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/photo1-1-d40365e5d252a5a5101743541a621012.webp"},43661:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/photo4-1-8e35963290570b9f138a2e5bb7649d94.webp"},28453:(e,t,i)=>{i.d(t,{R:()=>d,x:()=>o});var n=i(96540);const s={},r=n.createContext(s);function d(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);