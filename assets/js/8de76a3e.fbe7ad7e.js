"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6928],{42922:(e,s,n)=>{n.r(s),n.d(s,{ElectronicsTutorial:()=>m,assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>l,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"lab/02/index","title":"02 - GPIO","description":"General Purpose Input and Output using the Embassy Framework","source":"@site/versioned_docs/version-fils_en/lab/02/index.mdx","sourceDirName":"lab/02","slug":"/lab/02","permalink":"/docs/fils_en/lab/02","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/lab/02/index.mdx","tags":[],"version":"fils_en","frontMatter":{"description":"General Purpose Input and Output using the Embassy Framework","slug":"/lab/02"},"sidebar":"tutorialSidebar","previous":{"title":"01 - Debug","permalink":"/docs/fils_en/lab/01"},"next":{"title":"03 - PWM & ADC","permalink":"/docs/fils_en/lab/03"}}');var i=n(74848),r=n(28453),a=n(44070),d=n(11470),o=n(19365);const l={description:"General Purpose Input and Output using the Embassy Framework",slug:"/lab/02"},c="02 - GPIO",h={};function m({title:e,anchor:s}){const n=(0,a.ir)();return(0,i.jsx)("a",{href:`/docs/${n?.name}/tutorial/electronics${s?"#"+s:""}`,children:e||"Electronics"})}const u=[{value:"Concepts",id:"concepts",level:2},{value:"Resources",id:"resources",level:2},{value:"Extra Resources",id:"extra-resources",level:3},{value:"What is GPIO?",id:"what-is-gpio",level:2},{value:"Configuring GPIO Pins",id:"configuring-gpio-pins",level:2},{value:"Hardware access",id:"hardware-access",level:2},{value:"Embassy Framework",id:"embassy-framework",level:2},{value:"The Software Stack",id:"the-software-stack",level:3},{value:"<em>Empty</em> Embassy Firmware",id:"empty-embassy-firmware",level:3},{value:"Entry",id:"entry",level:3},{value:"Configure GPIO Output",id:"configure-gpio-output",level:3},{value:"Configure GPIO Input",id:"configure-gpio-input",level:3},{value:"Waiting for GPIO Input",id:"waiting-for-gpio-input",level:3},{value:"Waiting",id:"waiting",level:3},{value:"The lab board",id:"the-lab-board",level:2},{value:"Wiring",id:"wiring",level:3},{value:"STM32 Nucleo\u2011U545RE\u2011Q Pins",id:"stm32-nucleou545req-pins",level:3},{value:"LEDs and Switches",id:"leds-and-switches",level:3},{value:"Example",id:"example",level:3},{value:"Exercises",id:"exercises",level:2}];function p(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"02---gpio",children:"02 - GPIO"})}),"\n","\n","\n",(0,i.jsxs)(s.p,{children:["The purpose of this lab is to understand how to start developing firmware in ",(0,i.jsx)(s.a,{href:"https://www.rust-lang.org/",children:"Rust"}),"\nwith ",(0,i.jsx)(s.a,{href:"https://embassy.dev",children:"Embassy"})," for the STM32U545 and RP2 MCUs."]}),"\n","\n",(0,i.jsx)(s.h2,{id:"concepts",children:"Concepts"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"How to setup an empty project that uses Embassy;"}),"\n",(0,i.jsx)(s.li,{children:"How to use the lab board;"}),"\n",(0,i.jsx)(s.li,{children:"How to use GPIO pins from Embassy;"}),"\n",(0,i.jsx)(s.li,{children:"How to use the lab board's LEDs"}),"\n",(0,i.jsx)(s.li,{children:"How to use the lab board's switches"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://embassy.dev/book/",children:"Embassy Book"})})," - an overview of the ",(0,i.jsx)(s.em,{children:"Embassy"})," framework","\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.em,{children:"For Beginners"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:(0,i.jsxs)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32u545re/index.html",children:[(0,i.jsx)(s.code,{children:"embassy-stm32"}),"'s Documentation"]})})," - the API for the STM32U545"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:(0,i.jsxs)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:[(0,i.jsx)(s.code,{children:"embassy-rp"}),"'s Documentation"]})})," - the API for the RP2040 and RP2350"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"The Rusty Bits"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://www.youtube.com/watch?v=pDd5mXBF4tY",children:"Intro to Embassy : embedded development with async Rust"})})]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"extra-resources",children:"Extra Resources"}),"\n",(0,i.jsxs)(s.ol,{start:"4",children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"STMicroelectronics"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://www.st.com/resource/en/datasheet/stm32u545ce.pdf",children:"STM32U545 Datasheet"})})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf",children:"RP2350 Datasheet"})})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf",children:"Raspberry Pi Pico 2 Datasheet"})})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/picow/pico-2-w-datasheet.pdf",children:"Raspberry Pi Pico 2W Datasheet"})})]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"what-is-gpio",children:"What is GPIO?"}),"\n",(0,i.jsx)(s.p,{children:"General-Purpose Input/Output, or GPIO, is an essential part of embedded systems that serves as a vital conduit between microcontrollers and microprocessors and the outside world. A microcontroller or microprocessor's group of pins that can each be set to operate as an input or an output is referred to as GPIO. The purpose of these pins is to interface external components, including actuators, displays, sensors, and other devices, so that the embedded system may communicate with its surroundings. Standardised communication protocols like SPI, I2C, PCM, PWM, and serial communication may be directly supported by some GPIO pins. There are two varieties of GPIO pins: digital and analog."}),"\n",(0,i.jsx)(s.h2,{id:"configuring-gpio-pins",children:"Configuring GPIO Pins"}),"\n",(0,i.jsx)(s.p,{children:"GPIO pins can be used as outputs (LEDs, motors, buzzers) or as inputs (buttons, sensors)."}),"\n",(0,i.jsxs)(s.p,{children:["Every pin of the MCU can perform multiple functions. Several peripherals need to use input and output pins.\nIt is the role of the ",(0,i.jsx)(s.em,{children:"IO Bank0"})," to multiplex and connect the peripherals to the pins."]}),"\n",(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,i.jsx)(s.p,{children:"The STM32U545 controls the GPIO pins through several GPIO Ports (PortA, PortB, PortC, PortD, PortE, etc.). Using GPIOs implies configuring the:"}),(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"MODER"})," - connects the outer GPIO pin to one of the:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["internal ",(0,i.jsx)(s.code,{children:"GPIO"})," peripheral as ",(0,i.jsx)(s.code,{children:"input"})]}),"\n",(0,i.jsxs)(s.li,{children:["internal ",(0,i.jsx)(s.code,{children:"GPIO"})," peripheral as ",(0,i.jsx)(s.code,{children:"output"})]}),"\n",(0,i.jsxs)(s.li,{children:["one of the alternate function peripheral (further selected by the ",(0,i.jsx)(s.em,{children:"Alternate Function Multiplexer"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["the ",(0,i.jsx)(s.code,{children:"ADC"})," peripheral"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Electrical Configuration"})," - manages the physical pin on the outside of the chip. It decides the electrical behavior of the pad, such as whether it has a pull\u2011up or pull\u2011down resistor, whether it drives strongly or weakly, and whether it is push\u2011pull or open\u2011drain."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Alternate Function Multiplexer"})," - connects the internal peripherals to the outside pins. Each pin can be switched to different functions. For example, a single pin can be used as:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["a ",(0,i.jsx)(s.code,{children:"UART"})," transmit line"]}),"\n",(0,i.jsxs)(s.li,{children:["an ",(0,i.jsx)(s.code,{children:"I2C"})," data line"]}),"\n",(0,i.jsxs)(s.li,{children:["an ",(0,i.jsx)(s.code,{children:"SPI"})," clock or data line"]}),"\n",(0,i.jsxs)(s.li,{children:["a ",(0,i.jsx)(s.code,{children:"TIM"})," timer channel"]}),"\n",(0,i.jsxs)(s.li,{children:["a ",(0,i.jsx)(s.code,{children:"PWM"})," timer channel"]}),"\n",(0,i.jsx)(s.li,{children:"..."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"GPIO Input/Output"})," - this is the simple digital interface that developers use when they want to read or write a pin directly in software. It\u2019s what you use to toggle an LED or read a button."]}),"\n"]}),(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"STM32 Nucleo-U545RE-Q Pinout",src:n(79698).A+"",width:"1600",height:"1250"})}),(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsx)(s.p,{children:"The pins in pink represent the Arduino header pins."})})]}),(0,i.jsxs)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:[(0,i.jsx)(s.p,{children:"The RP2040 and RP2350 have three peripherals that control the GPIO pins:"}),(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Pads"})," - control the actual physical pin or pad that the processor has outside. They control the electrical parameters, like maximum current or pull up and pull down resistors"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"IO Bank0"})," - connects and multiplexes the peripheral's pins to the output pads. Several peripherals use the same output pad to communicate with the exterior. For example, in the image below, ",(0,i.jsx)(s.code,{children:"GPIO0"})," can be used either for:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"SIO"})," - the ",(0,i.jsx)(s.code,{children:"GPIO"})," function"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"SPI_RX"})," - the receive pin for the ",(0,i.jsx)(s.code,{children:"SPI"})," peripheral"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"I2C0_SDA"})," - the data pin for the ",(0,i.jsx)(s.code,{children:"I2C0"})," peripheral"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"UART0_TX"})," - the transmit pin for the ",(0,i.jsx)(s.code,{children:"UART0"})," (serial port 0) peripheral"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"SIO"})," - that controls the interior MCU's pins. This is the peripheral that developers use to read and write the value of the pins.\n",(0,i.jsx)(s.img,{alt:"Pico2W Pinout",src:n(54707).A+"",width:"842",height:"595"})]}),"\n"]}),(0,i.jsx)("div",{align:"center",children:(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"IO Bank0",src:n(24712).A+"",width:"1574",height:"1114"})})})]})]}),"\n",(0,i.jsx)(s.h2,{id:"hardware-access",children:"Hardware access"}),"\n",(0,i.jsx)(s.p,{children:"There are 3 different ways in which the hardware either on the STM32 Nucleo-U545RE-Q or the Raspberry Pi Pico 2 can be used:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Embassy framework, with the Embedded HAL implementation"}),"\n",(0,i.jsx)(s.li,{children:"Platform Access Crate (PAC)"}),"\n",(0,i.jsx)(s.li,{children:"Bare metal"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"embassy-framework",children:"Embassy Framework"}),"\n",(0,i.jsx)(s.p,{children:"Developing bare metal firmware requires a lot of time."}),"\n",(0,i.jsxs)(s.p,{children:["In trying to standardize firmware development, The Rust ",(0,i.jsx)(s.a,{href:"https://www.rust-lang.org/governance/wgs/embedded",children:"Embedded devices Working Group"})," has designed\na set of standard traits (interfaces) for interacting with an MCU. This is called the ",(0,i.jsx)(s.strong,{children:"Embedded Hardware Abstraction Layer"}),", or shortly Embedded HAL. The main purpose is to define a common hardware interface that\nframeworks, libraries and operating systems can build upon. Regardless of what MCUs the device is using, the upper level software should be as portable as possible."]}),"\n",(0,i.jsxs)(s.p,{children:["There are several crates that implement the Embedded HAL traits for the STM32U545, RP2040 and RP2350 MCUs. These\ncrates are called ",(0,i.jsx)(s.em,{children:"HAL Implementations"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32u545re/index.html",children:"embassy-stm32"})," - crate implements the Embedded HAL for STM32U545 that is used with the ",(0,i.jsx)(s.a,{href:"https://embassy.dev/",children:"embassy-rs"})," framework"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/rp235x-hal/latest/rp235x_hal/",children:"rp2350_hal"})," crate, implements just the embedded HAL traits, it is ",(0,i.jsx)(s.em,{children:"the bare minimum"})," for developing RP2350 applications"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/rp2040-hal/latest/rp2040_hal/",children:"rp2040_hal"})," crate, implements just the embedded HAL traits, it is ",(0,i.jsx)(s.em,{children:"the bare minimum"})," for developing RP2040 applications"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:"embassy-rp"})," crate implements the Embedded HAL for RP2040 and RP2350 that is used with the ",(0,i.jsx)(s.a,{href:"https://embassy.dev/",children:"embassy-rs"})," framework"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Several frameworks are available on top of the ",(0,i.jsx)(s.em,{children:"HAL Implementations"})," to speed things up. The most common used ones are:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://rtic.rs",children:"RTIC - The hardware accelerated Rust RTOS"})," - ",(0,i.jsx)(s.em,{children:"A concurrency framework for building real-time systems"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://embassy.dev",children:"Embassy"})," - ",(0,i.jsx)(s.em,{children:"The next-generation framework for embedded applications"})]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"the-software-stack",children:"The Software Stack"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://embassy.dev/",children:"Embassy"})," is a full fledged embedded framework for Rust embedded development.\nBesides the implementation of the embedded HAL for different MCUs (STM32U545, RP2350 and RP2040 included), Embassy provides\nseveral functions like timers, BLE and network communication."]}),"\n",(0,i.jsx)("div",{align:"center",children:(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Rust EMbedded Stack",src:n(73297).A+"",width:"451",height:"291"})})}),"\n",(0,i.jsx)(s.p,{children:"The crates used by Embassy and their mapping are shown in the table below."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Crate"}),(0,i.jsx)(s.th,{children:"Position"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-executor/git/cortex-m/index.html",children:(0,i.jsx)(s.code,{children:"embassy-executor"})})}),(0,i.jsx)(s.td,{children:"Framework"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/smoltcp/latest/smoltcp/",children:(0,i.jsx)(s.code,{children:"smoltcp"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.rs/defmt/latest/defmt/",children:(0,i.jsx)(s.code,{children:"defmt"})})]}),(0,i.jsx)(s.td,{children:"Libraries"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-net/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-net"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-time/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-time"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-usb"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb-logger/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-usb-logger"})})]}),(0,i.jsx)(s.td,{children:"Framework Driver"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb-driver/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-usb-driver"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-time-driver/git/default/index.html",children:(0,i.jsx)(s.code,{children:"embassy-time-driver"})})]}),(0,i.jsx)(s.td,{children:"Embassy HAL (API)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/cyw43/git/default/index.html",children:(0,i.jsx)(s.code,{children:"cyw43"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/cyw43-pio/git/default/index.html",children:(0,i.jsx)(s.code,{children:"cyw43-pio"})})]}),(0,i.jsx)(s.td,{children:"Driver (WiFi)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/embedded-hal/latest/embedded_hal/",children:(0,i.jsx)(s.code,{children:"embedded-hal"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.rs/embedded-hal-async/latest/embedded_hal_async/",children:(0,i.jsx)(s.code,{children:"embedded-hal-async"})})]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.strong,{children:"Rust Embedded HAL (Standard)"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32u545re/index.html",children:(0,i.jsx)(s.code,{children:"embassy_stm32"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:(0,i.jsx)(s.code,{children:"embassy_rp"})})]}),(0,i.jsx)(s.td,{children:"HAL Implementation"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/cortex-m/latest/cortex_m/",children:(0,i.jsx)(s.code,{children:"cortex-m"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.rs/cortex-m-rt/latest/cortex_m_rt/",children:(0,i.jsx)(s.code,{children:"cortex-m-rt"})})]}),(0,i.jsx)(s.td,{children:"\u03bc-architecture crates"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.a,{href:"https://github.com/embassy-rs/stm32-data-generated",children:(0,i.jsx)(s.code,{children:"stm32-metapac"})}),", ",(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/rp-pac/git/default/index.html",children:(0,i.jsx)(s.code,{children:"rp_pac"})})]}),(0,i.jsx)(s.td,{children:"Platform Access Crate"})]})]})]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["The name ",(0,i.jsx)(s.em,{children:"Embassy"})," is derived from ",(0,i.jsx)(s.strong,{children:"Emb"}),"edded ",(0,i.jsx)(s.strong,{children:"Asy"}),"nchronous Rust."]})}),"\n",(0,i.jsxs)(s.h3,{id:"empty-embassy-firmware",children:[(0,i.jsx)(s.em,{children:"Empty"})," Embassy Firmware"]}),"\n",(0,i.jsxs)(s.p,{children:["The Embassy Framework is a collection of crates. Building an ",(0,i.jsx)(s.em,{children:"empty"})," firmware that uses\nembassy requires:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"adding the Embassy HAL Implementation for a specific board, in this case STM32U545 or RP2350;"}),"\n",(0,i.jsx)(s.li,{children:"adding the core Embassy crates, that provide the executor, timers and futures;"}),"\n",(0,i.jsxs)(s.li,{children:["adding the ",(0,i.jsx)(s.code,{children:"cortex-m-rt"})," and ",(0,i.jsx)(s.code,{children:"defmt"})," crates that Embassy requires."]}),"\n"]}),"\n",(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-toml",children:'[dependencies]\nembassy-stm32 = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["defmt", "stm32u545re", "unstable-pac", "memory-x", "time-driver-tim4", "exti", "chrono"] }\n\n# Embedded HAL utilities\nembassy-embedded-hal = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["defmt"] }\n\n# Synchronization primitives and data structures with async support\nembassy-sync = { version = "0.7.2", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["defmt"] }\n\n# Async/await executor\nembassy-executor = { version = "0.9.0", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["arch-cortex-m", "executor-thread", "defmt"] }\n\n# Utilities for working with futures, compatible with no_std and not using alloc\nembassy-futures = { version = "0.1.2", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe" }\n\n# Timekeeping, delays and timeouts\nembassy-time = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["defmt", "defmt-timestamp-uptime", "tick-hz-32_768"] }\n\n# USB device\n# embassy-usb = { version = "0.5.1", git = "https://github.com/embassy-rs/embassy", rev = "3e8d8fe", features = ["defmt"] }\n\n# Defmt support\ndefmt = "0.3"\ndefmt-rtt = "0.4"\n\n# Low level access to Cortex-M processors\ncortex-m = { version = "0.7.7", features = ["inline-asm", "critical-section-single-core"] }\n\n# Boostrap crate for Cortex-M Processors\ncortex-m-rt = "0.7.5"\n\n# Panic handler that exits `probe-run` with an error code\npanic-probe = { version = "1.0.0", features = ["print-defmt"] }\n'})}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-stm32"})," crate provides support for the STM32 Nucleo-U545RE-Q microcontroller within the Embassy framework. It includes features such as ",(0,i.jsx)(s.code,{children:"defmt"})," for efficient debugging, ",(0,i.jsx)(s.code,{children:"unstable-pac"})," for accessing low-level peripherals, and time-driver for handling ",(0,i.jsx)(s.code,{children:"time-related"})," operations. The crate also implements ",(0,i.jsx)(s.code,{children:"critical-section"})," for safe concurrency and supports STM32U545RETxQ and ",(0,i.jsx)(s.code,{children:"binary-info"})," for additional STM32U545-specific functionality."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-embedded-hal"})," crate provides embedded-hal-compatible utilities for asynchronous embedded development. It enables easy interaction with hardware peripherals, such as GPIO, SPI, and I2C, while integrating with the Embassy async runtime. It includes ",(0,i.jsx)(s.code,{children:"defmt"})," for lightweight debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-sync"})," crate offers synchronization primitives and data structures designed for async environments. It includes mutexes, signal primitives, and channel-based communication for safe, cooperative multitasking. The crate is optimized for ",(0,i.jsx)(s.code,{children:"no_std"})," systems and supports ",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-executor"})," crate provides an async/await executor tailored for embedded systems. It supports multitasking via interrupt-based and thread-based execution models, with optimizations for Cortex-M microcontrollers. Features include configurable task arena sizes and ",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-futures"})," crate supplies utilities for working with Rust futures in embedded environments. It is designed to be compatible with ",(0,i.jsx)(s.code,{children:"no_std"})," and avoids dynamic memory allocation, making it lightweight and efficient for constrained devices."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-usb"})," crate provides a USB device stack for embedded systems. It supports USB control, bulk, and interrupt transfers, making it useful for implementing HID, CDC, and other USB classes. It integrates with ",(0,i.jsx)(s.code,{children:"defmt"})," for debugging and logging."]})]}),(0,i.jsxs)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-toml",children:'[dependencies]\nembassy-rp = { version = "0.8.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "unstable-pac", "time-driver", "critical-section-impl", "rp235xa", "binary-info"] }\n\n# Embedded HAL utilities\nembassy-embedded-hal = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Synchronization primitives and data structures with async support\nembassy-sync = { version = "0.7.2", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Async/await executor\nembassy-executor = { version = "0.9.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["task-arena-size-98304", "arch-cortex-m", "executor-thread", "executor-interrupt", "defmt"] }\n\n# Utilities for working with futures, compatible with no_std and not using alloc\nembassy-futures = { version = "0.1.2", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\n\n# Timekeeping, delays and timeouts\nembassy-time = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "defmt-timestamp-uptime"] }\n\n# USB device\nembassy-usb = { version = "0.5.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Network stack\nembassy-net = { version = "0.7.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "tcp", "udp", "raw", "dhcpv4", "medium-ethernet", "dns"] }\nembassy-net-wiznet = { version = "0.2.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# USB logging\nembassy-usb-logger = { version = "0.5.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\nlog = "0.4"\n\n# WiFi Chip\ncyw43 = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "firmware-logs"] }\ncyw43-pio = { version = "0.7.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Defmt support\ndefmt = "0.3"\ndefmt-rtt = "0.4"\n\n# Low level access to Cortex-M processors\n# cortex-m = { version = "0.7.6", features = ["inline-asm"] }\ncortex-m-rt = "0.7.0"\n\n# Panic handler that exits `probe-run` with an error code\npanic-probe = { version = "0.3", features = ["print-defmt"] }\n'})}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-rp"})," crate provides support for the Raspberry Pi RP2350\nmicrocontroller within the Embassy framework. It includes features such\nas ",(0,i.jsx)(s.code,{children:"defmt"})," for efficient debugging, ",(0,i.jsx)(s.code,{children:"unstable-pac"})," for accessing low-level\nperipherals, and ",(0,i.jsx)(s.code,{children:"time-driver"})," for handling time-related operations.\nThe crate also implements ",(0,i.jsx)(s.code,{children:"critical-section"})," for safe concurrency and\nsupports ",(0,i.jsx)(s.code,{children:"rp235xa"})," and ",(0,i.jsx)(s.code,{children:"binary-info"})," for additional RP2350-specific\nfunctionality."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-embedded-hal"})," crate provides embedded-hal-compatible utilities\nfor asynchronous embedded development. It enables easy interaction with\nhardware peripherals, such as GPIO, SPI, and I2C, while integrating with\nthe Embassy async runtime. It includes ",(0,i.jsx)(s.code,{children:"defmt"})," for lightweight debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-sync"})," crate offers synchronization primitives and data\nstructures designed for async environments. It includes mutexes, signal\nprimitives, and channel-based communication for safe, cooperative\nmultitasking. The crate is optimized for ",(0,i.jsx)(s.code,{children:"no_std"})," systems and supports\n",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-executor"})," crate provides an async/await executor tailored for\nembedded systems. It supports multitasking via interrupt-based and\nthread-based execution models, with optimizations for Cortex-M\nmicrocontrollers. Features include configurable task arena sizes and\n",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-futures"})," crate supplies utilities for working with Rust futures\nin embedded environments. It is designed to be compatible with ",(0,i.jsx)(s.code,{children:"no_std"}),"\nand avoids dynamic memory allocation, making it lightweight and efficient\nfor constrained devices."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-time"})," crate handles timekeeping, delays, and timeouts in async\napplications. It provides a high-precision time driver and supports uptime-based\ntimestamps for logging. The crate is optimized for ",(0,i.jsx)(s.code,{children:"no_std"}),"\nenvironments and integrates with ",(0,i.jsx)(s.code,{children:"defmt"}),"."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-usb"})," crate provides a USB device stack for embedded systems. It\nsupports USB control, bulk, and interrupt transfers, making it useful for\nimplementing HID, CDC, and other USB classes. It integrates with ",(0,i.jsx)(s.code,{children:"defmt"}),"\nfor debugging and logging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-net"})," crate implements a network stack with support for TCP,\nUDP, and raw Ethernet frames. It includes DHCPv4 for automatic IP\nconfiguration and DNS resolution. The crate is designed for embedded\nnetworking and integrates with ",(0,i.jsx)(s.code,{children:"defmt"})," for efficient debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-net-wiznet"})," crate adds support for WIZnet Ethernet modules to\nthe Embassy networking stack. It provides an async interface for handling\nnetwork communication over SPI-connected WIZnet chips, with ",(0,i.jsx)(s.code,{children:"defmt"}),"\nintegration for logging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-usb-logger"})," crate enables USB-based logging for embedded\napplications. It provides a mechanism for transmitting log messages over\nUSB, allowing for real-time debugging and monitoring of embedded systems."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"log"})," crate is a lightweight logging facade that allows messages to be\nrecorded using different logging backends. It is widely used in Rust\nprojects, including embedded systems, to enable flexible debugging and\nmonitoring."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"cyw43"})," crate provides support for the CYW43 Wi-Fi chip, commonly found\non Raspberry Pi Pico W. It includes firmware logging, ",(0,i.jsx)(s.code,{children:"defmt"})," integration,\nand an async interface for managing Wi-Fi connections in embedded systems."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"cyw43-pio"})," crate offers PIO (Programmable I/O) support for the CYW43\nWi-Fi chip, enabling efficient SPI communication between the microcontroller\nand the Wi-Fi module. It includes ",(0,i.jsx)(s.code,{children:"defmt"})," logging for debugging low-level\ninteractions."]})]}),(0,i.jsxs)(o.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-toml",children:'[dependencies]\nembassy-rp = { version = "0.8.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "unstable-pac", "time-driver", "critical-section-impl", "rp2040", "binary-info"] }\n\n# Embedded HAL utilities\nembassy-embedded-hal = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Synchronization primitives and data structures with async support\nembassy-sync = { version = "0.7.2", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Async/await executor\nembassy-executor = { version = "0.9.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["task-arena-size-98304", "arch-cortex-m", "executor-thread", "executor-interrupt", "defmt"] }\n\n# Utilities for working with futures, compatible with no_std and not using alloc\nembassy-futures = { version = "0.1.2", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\n\n# Timekeeping, delays and timeouts\nembassy-time = { version = "0.5.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "defmt-timestamp-uptime"] }\n\n# USB device\nembassy-usb = { version = "0.5.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Network stack\nembassy-net = { version = "0.7.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "tcp", "udp", "raw", "dhcpv4", "medium-ethernet", "dns"] }\nembassy-net-wiznet = { version = "0.2.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# USB logging\nembassy-usb-logger = { version = "0.5.1", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\nlog = "0.4"\n\n# WiFi Chip\ncyw43 = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "firmware-logs"] }\ncyw43-pio = { version = "0.7.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Defmt support\ndefmt = "0.3"\ndefmt-rtt = "0.4"\n\n# Low level access to Cortex-M processors\n# cortex-m = { version = "0.7.6", features = ["inline-asm"] }\ncortex-m-rt = "0.7.0"\n\n# Panic handler that exits `probe-run` with an error code\npanic-probe = { version = "0.3", features = ["print-defmt"] }\n'})}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-rp"})," crate provides support for the Raspberry Pi RP2040\nmicrocontroller within the Embassy framework. It includes features such\nas ",(0,i.jsx)(s.code,{children:"defmt"})," for efficient debugging, ",(0,i.jsx)(s.code,{children:"unstable-pac"})," for accessing low-level\nperipherals, and ",(0,i.jsx)(s.code,{children:"time-driver"})," for handling time-related operations.\nThe crate also implements ",(0,i.jsx)(s.code,{children:"critical-section"})," for safe concurrency and\nsupports ",(0,i.jsx)(s.code,{children:"rp2040"})," and ",(0,i.jsx)(s.code,{children:"binary-info"})," for additional RP2350-specific\nfunctionality."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-embedded-hal"})," crate provides embedded-hal-compatible utilities\nfor asynchronous embedded development. It enables easy interaction with\nhardware peripherals, such as GPIO, SPI, and I2C, while integrating with\nthe Embassy async runtime. It includes ",(0,i.jsx)(s.code,{children:"defmt"})," for lightweight debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-sync"})," crate offers synchronization primitives and data\nstructures designed for async environments. It includes mutexes, signal\nprimitives, and channel-based communication for safe, cooperative\nmultitasking. The crate is optimized for ",(0,i.jsx)(s.code,{children:"no_std"})," systems and supports\n",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-executor"})," crate provides an async/await executor tailored for\nembedded systems. It supports multitasking via interrupt-based and\nthread-based execution models, with optimizations for Cortex-M\nmicrocontrollers. Features include configurable task arena sizes and\n",(0,i.jsx)(s.code,{children:"defmt"})," for debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-futures"})," crate supplies utilities for working with Rust futures\nin embedded environments. It is designed to be compatible with ",(0,i.jsx)(s.code,{children:"no_std"}),"\nand avoids dynamic memory allocation, making it lightweight and efficient\nfor constrained devices."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-time"})," crate handles timekeeping, delays, and timeouts in async\napplications. It provides a high-precision time driver and supports uptime-based\ntimestamps for logging. The crate is optimized for ",(0,i.jsx)(s.code,{children:"no_std"}),"\nenvironments and integrates with ",(0,i.jsx)(s.code,{children:"defmt"}),"."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-usb"})," crate provides a USB device stack for embedded systems. It\nsupports USB control, bulk, and interrupt transfers, making it useful for\nimplementing HID, CDC, and other USB classes. It integrates with ",(0,i.jsx)(s.code,{children:"defmt"}),"\nfor debugging and logging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-net"})," crate implements a network stack with support for TCP,\nUDP, and raw Ethernet frames. It includes DHCPv4 for automatic IP\nconfiguration and DNS resolution. The crate is designed for embedded\nnetworking and integrates with ",(0,i.jsx)(s.code,{children:"defmt"})," for efficient debugging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-net-wiznet"})," crate adds support for WIZnet Ethernet modules to\nthe Embassy networking stack. It provides an async interface for handling\nnetwork communication over SPI-connected WIZnet chips, with ",(0,i.jsx)(s.code,{children:"defmt"}),"\nintegration for logging."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy-usb-logger"})," crate enables USB-based logging for embedded\napplications. It provides a mechanism for transmitting log messages over\nUSB, allowing for real-time debugging and monitoring of embedded systems."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"log"})," crate is a lightweight logging facade that allows messages to be\nrecorded using different logging backends. It is widely used in Rust\nprojects, including embedded systems, to enable flexible debugging and\nmonitoring."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"cyw43"})," crate provides support for the CYW43 Wi-Fi chip, commonly found\non Raspberry Pi Pico W. It includes firmware logging, ",(0,i.jsx)(s.code,{children:"defmt"})," integration,\nand an async interface for managing Wi-Fi connections in embedded systems."]}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"cyw43-pio"})," crate offers PIO (Programmable I/O) support for the CYW43\nWi-Fi chip, enabling efficient SPI communication between the microcontroller\nand the Wi-Fi module. It includes ",(0,i.jsx)(s.code,{children:"defmt"})," logging for debugging low-level\ninteractions."]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"entry",children:"Entry"}),"\n",(0,i.jsxs)(s.p,{children:["Embassy is a framework built on top of ",(0,i.jsx)(s.code,{children:"cortex-m-rt"})," and provides its own method of defining\nthe entrypoint and bootloader."]}),"\n",(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"#![no_main]\n#![no_std]\n\nuse embassy_executor::Spawner;\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let peripherals = embassy_stm32::init(Default::default());\n}\n"})}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy_stm32::init"})," function takes care of the peripheral initialization so that developers can jump\nright in and use them."]})]}),(0,i.jsxs)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 1 / 2",default:!0,children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"#![no_main]\n#![no_std]\n\nuse embassy_executor::Spawner;\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let peripherals = embassy_rp::init(Default::default());\n}\n"})}),(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"embassy_rp::init"})," function takes care of the peripheral initialization so that developers can jump\nright in and use them."]})]})]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["Embassy is designed to work in an asynchronous way and this is why the ",(0,i.jsx)(s.code,{children:"main"})," function is defined as ",(0,i.jsx)(s.code,{children:"async"}),". For the time being, just take it as a must and ignore it."]})}),"\n",(0,i.jsx)(s.h3,{id:"configure-gpio-output",children:"Configure GPIO Output"}),"\n",(0,i.jsxs)(s.p,{children:["Embassy provides one single function that returns the GPIO ",(0,i.jsx)(s.code,{children:"Output"})," pin and hides the configuration\ndetails from developers."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"pin"})," variable implements the embadded HAL ",(0,i.jsx)(s.a,{href:"https://docs.rs/embedded-hal/latest/embedded_hal/digital/trait.OutputPin.html",children:(0,i.jsx)(s.code,{children:"OutputPin"})})," trait."]}),"\n",(0,i.jsxs)(d.A,{children:[(0,i.jsx)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"use gpio::{Level, Output, Speed};\n\n// initialize PXn\n//   - replace X with the port letter(A, B, C, D, E, etc.)\n//   - n with the pin number\n//   ... see the datasheet, e.g. PA5 \n// and set its default value to LOW (0)\nlet mut pin = Output::new(peripherals.PXn, Level::Low, Speed::Medium);\n\n// set the pin value to HIGH (1)\npin.set_high();\n\n// set the pin value to LOW (0)\npin.set_low();\n"})})}),(0,i.jsx)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 1 / 2",default:!0,children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"use gpio::{Level, Output};\n\n// initialize PIN_n (replace n with a number) and set its\n// default value to LOW (0)\nlet mut pin = Output::new(peripherals.PIN_n, Level::Low);\n\n// set the pin value to HIGH (1)\npin.set_high();\n\n// set the pin value to LOW (0)\npin.set_low();\n"})})})]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsx)(s.p,{children:"While the device initialization is specific to each hardware family, the pin initialization and usage is mostly portable. The same basic API applies across MCUs, but STM32 devices require an additional parameter for pin speed, since their GPIOs expose configurable slew rates. By contrast, RP2 devices (RP2040 / RP2350) use a simpler form without speed configuration."})}),"\n",(0,i.jsx)(s.h3,{id:"configure-gpio-input",children:"Configure GPIO Input"}),"\n",(0,i.jsx)(s.p,{children:"Using a pin as input is very similar to using it as output."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"use gpio::{Input, Pull};\n\nlet pin = Input::new(peripherals.PXn, Pull::Up);\n\nif pin.is_high() {\n    // Do something if the pin value is HIGH (1)\n} else {\n    // Do something if the pin value if LOW (0)\n}\n"})}),"\n",(0,i.jsxs)(s.admonition,{type:"warning",children:[(0,i.jsx)(s.mdxAdmonitionTitle,{}),(0,i.jsxs)(s.p,{children:["For a correct use of the buttons, use pull-up, pull-down resistors depending on the mode of operation of the button. Check ",(0,i.jsx)(m,{title:"Buttons",anchor:"buttons"})," section from the ",(0,i.jsx)(m,{}),"."]})]}),"\n",(0,i.jsx)(s.h3,{id:"waiting-for-gpio-input",children:"Waiting for GPIO Input"}),"\n",(0,i.jsx)(s.p,{children:"Embassy provides a set of functions that are able to suspend the execution of the task\nuntil a change is detected in the input if a GPIO pin."}),"\n",(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,i.jsxs)(s.p,{children:["When working with microcontrollers like the ",(0,i.jsx)(s.strong,{children:"STM32U5"}),", the processor needs a way to respond immediately to external events\u2014such as a button press, a sensor trigger, or a signal change on a pin.\nThis is where the ",(0,i.jsx)(s.strong,{children:"Extended Interrupt"})," and ",(0,i.jsx)(s.strong,{children:"Event Controller"}),", or ",(0,i.jsx)(s.code,{children:"EXTI"}),", comes in."]}),(0,i.jsx)(s.p,{children:"The EXTI (Extended Interrupts and Events Controller) is a hardware peripheral inside the STM32 that:"}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Detects external events on certain pins (like buttons or sensors)."}),"\n",(0,i.jsx)(s.li,{children:"Generates interrupts or wake-up signals to alert the CPU."}),"\n",(0,i.jsx)(s.li,{children:"Can wake the MCU from low-power modes (like Stop or Sleep modes)."}),"\n"]}),(0,i.jsx)(s.p,{children:"The EXTI peripheral uses something called the EXTI multiplexer (EXTI MUX) to connect external pins to EXTI lines."}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"There are 16 EXTI lines (0\u201315) that can be linked to GPIO pins."}),"\n",(0,i.jsx)(s.li,{children:"The connection is configured through registers (EXTI_EXTICR), where you select which port (A, B, C, etc.) connects to each EXTI line."}),"\n"]}),(0,i.jsxs)(s.admonition,{type:"warning",children:[(0,i.jsx)(s.p,{children:"Not every pin can have its own interrupt line!\nThere are only 16 EXTI lines for all GPIOs, so:"}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"PA0"}),", ",(0,i.jsx)(s.code,{children:"PB0"}),", ",(0,i.jsx)(s.code,{children:"PC0"}),", ",(0,i.jsx)(s.code,{children:"PD0"}),", etc. all share EXTI line 0."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"PA1"}),", ",(0,i.jsx)(s.code,{children:"PB1"}),", ",(0,i.jsx)(s.code,{children:"PC1"}),", ",(0,i.jsx)(s.code,{children:"PD1"}),", etc. all share EXTI line 1"]}),"\n",(0,i.jsx)(s.li,{children:"and so on"}),"\n"]}),(0,i.jsxs)(s.p,{children:["So if you use ",(0,i.jsx)(s.code,{children:"PB0"})," and ",(0,i.jsx)(s.code,{children:"PC0"})," simultaneously, they will share the same interrupt line, and your code must check which pin actually triggered the interrupt."]})]}),(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.img,{alt:"EXTI Line Connections",src:n(75137).A+"",width:"887",height:"525"}),"\n",(0,i.jsx)(s.img,{alt:"EXTI MUX GPIO",src:n(74493).A+"",width:"874",height:"416"})]}),(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32f042k6/exti/struct.ExtiInput.html#method.wait_for_high",children:(0,i.jsx)(s.code,{children:"wait_for_high"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,i.jsx)(s.code,{children:"Level::High"}),". If the pin state is already ",(0,i.jsx)(s.code,{children:"Level::High"}),", it returns immediately."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32f042k6/exti/struct.ExtiInput.html#method.wait_for_low",children:(0,i.jsx)(s.code,{children:"wait_for_low"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,i.jsx)(s.code,{children:"Level::Low"}),". If the pin state is already ",(0,i.jsx)(s.code,{children:"Level::Low"}),", it returns immediately."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32f042k6/exti/struct.ExtiInput.html#method.wait_for_any_edge",children:(0,i.jsx)(s.code,{children:"wait_for_any_edge"})})}),(0,i.jsx)(s.td,{children:"Suspends the execution until the pin state switches."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32f042k6/exti/struct.ExtiInput.html#method.wait_for_rising_edge",children:(0,i.jsx)(s.code,{children:"wait_for_rising_edge"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state switches from ",(0,i.jsx)(s.code,{children:"Level::Low"})," to ",(0,i.jsx)(s.code,{children:"Level::High"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-stm32/git/stm32f042k6/exti/struct.ExtiInput.html#method.wait_for_falling_edge",children:(0,i.jsx)(s.code,{children:"wait_for_falling_edge"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state switches ",(0,i.jsx)(s.code,{children:"Level::High"})," to ",(0,i.jsx)(s.code,{children:"Level::Low"})]})]})]})]})]}),(0,i.jsx)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 1 / 2",default:!0,children:(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_high",children:(0,i.jsx)(s.code,{children:"wait_for_high"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,i.jsx)(s.code,{children:"Level::High"}),". If the pin state is already ",(0,i.jsx)(s.code,{children:"Level::High"}),", it returns immediately."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_low",children:(0,i.jsx)(s.code,{children:"wait_for_low"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,i.jsx)(s.code,{children:"Level::Low"}),". If the pin state is already ",(0,i.jsx)(s.code,{children:"Level::Low"}),", it returns immediately."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_any_edge",children:(0,i.jsx)(s.code,{children:"wait_for_any_edge"})})}),(0,i.jsx)(s.td,{children:"Suspends the execution until the pin state switches."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_rising_edge",children:(0,i.jsx)(s.code,{children:"wait_for_rising_edge"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state switches from ",(0,i.jsx)(s.code,{children:"Level::Low"})," to ",(0,i.jsx)(s.code,{children:"Level::High"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_falling_edge",children:(0,i.jsx)(s.code,{children:"wait_for_falling_edge"})})}),(0,i.jsxs)(s.td,{children:["Suspends the execution until the pin state switches ",(0,i.jsx)(s.code,{children:"Level::High"})," to ",(0,i.jsx)(s.code,{children:"Level::Low"})]})]})]})]})})]}),"\n",(0,i.jsx)(s.h3,{id:"waiting",children:"Waiting"}),"\n",(0,i.jsxs)(s.p,{children:["Embassy provides support for suspending the execution of the software for an amount of time. It uses\nthe ",(0,i.jsx)(s.a,{href:"https://docs.rs/embassy-time/0.3.0/embassy_time/struct.Timer.html",children:(0,i.jsx)(s.code,{children:"Timer"})})," structure from the\n",(0,i.jsx)(s.a,{href:"https://docs.rs/embassy-time/latest/embassy_time/",children:(0,i.jsx)(s.code,{children:"embassy_time"})})," crate."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"// suspend the execution for a period of time\nuse embassy_time::Timer;\n\nTimer::after_secs(1).await;\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsx)(s.p,{children:"If the MCU provides timers, the Embassy framework will use them to suspend the software. This is very efficient."})}),"\n",(0,i.jsx)(s.h2,{id:"the-lab-board",children:"The lab board"}),"\n",(0,i.jsx)(s.p,{children:"This lab makes use of the hardware available on the lab board. The board provides:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Nucleo U545RE-Q Slot / Board"}),"\n",(0,i.jsx)(s.li,{children:"4 buttons"}),"\n",(0,i.jsx)(s.li,{children:"5 LEDs"}),"\n",(0,i.jsx)(s.li,{children:"potentiometer"}),"\n",(0,i.jsx)(s.li,{children:"buzzer"}),"\n",(0,i.jsx)(s.li,{children:"photoresistor"}),"\n",(0,i.jsx)(s.li,{children:"I2C EEPROM"}),"\n",(0,i.jsx)(s.li,{children:"MPU-6500 accelerometer & Gyro"}),"\n",(0,i.jsx)(s.li,{children:"BMP 390 Pressure sensor"}),"\n",(0,i.jsx)(s.li,{children:"SPI LCD Display"}),"\n",(0,i.jsx)(s.li,{children:"SD Card Reader"}),"\n",(0,i.jsx)(s.li,{children:"servo connectors"}),"\n",(0,i.jsx)(s.li,{children:"stepper motor"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Lab Board",src:n(21668).A+"",width:"2776",height:"2144"})}),"\n",(0,i.jsx)(s.admonition,{type:"danger",children:(0,i.jsxs)(s.p,{children:["Please make sure you use the ",(0,i.jsx)(s.strong,{children:"USB-C connector(USB STLK)"})," to connect the board to the computer."]})}),"\n",(0,i.jsx)(s.h3,{id:"wiring",children:"Wiring"}),"\n",(0,i.jsx)(s.p,{children:"All the electronic components, sensors and actuators, have the power pins hard wired\nto the board. This means that all the components receive power from the board\nand do not have to be powered separately."}),"\n",(0,i.jsxs)(s.p,{children:["The data pins of the components are not wired and have to be connected to the\nSTM32 Nucleo-U545RE-Q/Raspberry Pi Pico using ",(0,i.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Jump_wire",children:"jumper wires"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"stm32-nucleou545req-pins",children:"STM32 Nucleo\u2011U545RE\u2011Q Pins"}),"\n",(0,i.jsxs)(s.p,{children:["Each pin on the ",(0,i.jsx)(s.strong,{children:"STM32 Nucleo\u2011U545RE\u2011Q"})," is accessible through ",(0,i.jsx)(s.strong,{children:"Arduino\u2011compatible headers"})," and ",(0,i.jsx)(s.strong,{children:"ST morpho connectors"})," placed along the sides of the board. The Arduino headers are labeled with familiar names like ",(0,i.jsx)(s.strong,{children:"D0\u2013D15"})," and ",(0,i.jsx)(s.strong,{children:"A0\u2013A5"}),", while the morpho connectors (CN7, CN8, CN9, CN10) expose the full set of STM32 pins. To identify the exact STM32 signal (e.g., ",(0,i.jsx)(s.strong,{children:"PA5"}),", ",(0,i.jsx)(s.strong,{children:"PB14"}),"), you refer to the official pinout diagram in the board\u2019s documentation. These connectors provide flexible access to the ",(0,i.jsx)(s.strong,{children:"GPIO (General\u2011Purpose Input/Output)"})," pins of the Nucleo board for prototyping and interfacing."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Lab Board Connectors",src:n(59729).A+"",width:"1229",height:"1170"})}),"\n",(0,i.jsx)(s.p,{children:"You have to use jumper wires to interface with the STM32 Nucleo\u2011U545RE\u2011Q GPIO pins as follows:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Insert a ",(0,i.jsx)(s.strong,{children:"male jumper wire"})," into one of the pin holes corresponding to the desired GPIO pin."]}),"\n",(0,i.jsxs)(s.li,{children:["Connect ",(0,i.jsx)(s.strong,{children:"the other end"})," of the jumper wire to an external circuit, such as a breadboard,\nanother microcontroller, or a peripheral device. In this case, it will be LEDs or Switches."]}),"\n",(0,i.jsxs)(s.li,{children:["Use the ",(0,i.jsx)(s.strong,{children:"second hole"})," of the same pin as an additional connection point,\nallowing multiple devices to share the same GPIO."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"leds-and-switches",children:"LEDs and Switches"}),"\n",(0,i.jsxs)(s.p,{children:["The board provides four single colored LEDs, red, green, blue and yellow. Each one of them\nuses one pin for control. Each LED connector has one single hole on the board,\nmarked with ",(0,i.jsx)(s.code,{children:"RED"}),", ",(0,i.jsx)(s.code,{children:"GREEN"}),", ",(0,i.jsx)(s.code,{children:"BLUE"})," and ",(0,i.jsx)(s.code,{children:"YELLOW"})," respectively. These are located in the ",(0,i.jsx)(s.strong,{children:"Connectors"}),"\nsection of the board."]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(s.p,{children:["The LEDs are connected so they will light up if the pin is set to ",(0,i.jsx)(s.code,{children:"Level::Low"})," and turn off if the pin is set to ",(0,i.jsx)(s.code,{children:"Level::High"}),"."]})}),"\n",(0,i.jsxs)(s.p,{children:["The four switches that the lab board provides are signaled with labels\n",(0,i.jsx)(s.code,{children:"S1"}),", ",(0,i.jsx)(s.code,{children:"S2"}),", ",(0,i.jsx)(s.code,{children:"S3"})," and ",(0,i.jsx)(s.code,{children:"S4"})," in the connectors section."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Lab Board Connectors",src:n(65874).A+"",width:"1585",height:"740"})}),"\n",(0,i.jsxs)(s.admonition,{type:"warning",children:[(0,i.jsx)(s.p,{children:"Switches on the lab board have a pull-up resistor. This means that:"}),(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"The values it provides may be counter-intuitive:"}),"\n"]}),(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Position"}),(0,i.jsx)(s.th,{children:"Value"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Pressed"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Level::Low"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Released"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Level::High"})})]})]})]}),(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsxs)(s.li,{children:["Pins that connect to switches have to be set up as ",(0,i.jsx)(s.code,{children:"Pull::None"})," to disable the STM32 Nucleo\u2011U545RE\u2011Q's\ninternal pull resistor."]}),"\n"]})]}),"\n",(0,i.jsx)(s.h3,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(s.p,{children:["To wire the blue LED to pin PC7 of the STM32 Nucleo\u2011U545RE\u2011Q, a jumper cable is required\nbetween holes ",(0,i.jsx)(s.code,{children:"LED_BLUE"})," and ",(0,i.jsx)(s.code,{children:"IO/D8"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Lab Board Connectors",src:n(13589).A+"",width:"627",height:"1109"})}),"\n",(0,i.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Write an ",(0,i.jsx)(s.em,{children:"empty"})," firmware that uses the Embassy Framework and ",(0,i.jsx)(s.code,{children:"defmt"}),". (",(0,i.jsx)(s.strong,{children:"1p"}),")\nMake sure you follow these steps:"]}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["create a new Rust project using ",(0,i.jsx)(s.code,{children:"cargo init"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["add the ",(0,i.jsx)(s.code,{children:".cargo/config.toml"})," file that instructs ",(0,i.jsx)(s.code,{children:"cargo"})," to ",(0,i.jsx)(s.a,{href:"./01#using-a-configuration-file",children:"cross-compile"})," for the ",(0,i.jsx)(s.code,{children:"thumbv8m.main-none-eabihf"}),"\narchitecture, add ",(0,i.jsx)(s.code,{children:"probe-rs run"})," as a ",(0,i.jsx)(s.a,{href:"./01#using-cargo-run",children:"runner"})," and set ",(0,i.jsxs)(s.a,{href:"./01#filtering-messages",children:[(0,i.jsx)(s.code,{children:"defmt"})," messages filtering"]})," to ",(0,i.jsx)(s.code,{children:"DEBUG"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["add the ",(0,i.jsx)(s.a,{href:"./01#linker-script",children:"linker script"})," file called ",(0,i.jsx)(s.code,{children:"memory.x"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["add the ",(0,i.jsx)(s.a,{href:"./01#build-script",children:"build script"})," file called ",(0,i.jsx)(s.code,{children:"build.rs"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["add the required ",(0,i.jsx)(s.em,{children:"Embassy"})," dependencies - take a look at ",(0,i.jsxs)(s.a,{href:"#empty-embassy-firmware",children:[(0,i.jsx)(s.em,{children:"Empty"})," Embassy Firmware"]})," - take a look at ",(0,i.jsxs)(s.a,{href:"./01#empty-firmware",children:[(0,i.jsx)(s.em,{children:"Empty"})," Firmware"]}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["use ",(0,i.jsx)(s.code,{children:"defmt_rtt"})," as a logger, make sure you import it even if you are not using it directly ",(0,i.jsx)(s.code,{children:"use ... as _"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["use ",(0,i.jsx)(s.code,{children:"panic_probe"})," to provide a panic handler, make sure you import it even if you are not using it directly ",(0,i.jsx)(s.code,{children:"use ... as _"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["ask the Rust compiler not to depend on the standard library,\nnot to provide a main function and\nadd the ",(0,i.jsx)(s.em,{children:"Embassy"})," ",(0,i.jsx)(s.a,{href:"#entry",children:"entry"}),";"]}),"\n",(0,i.jsxs)(s.li,{children:["write the code to print the ",(0,i.jsx)(s.code,{children:"info!"}),' message "Device started".']}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Please make sure you comment out (using ",(0,i.jsx)(s.code,{children:"#"})," in from of the line) all the Embassy's crates\nthat you do not plan to use."]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"stm32u5",label:"STM32 Nucleo-U545RE-Q",default:!0,children:[(0,i.jsxs)(s.p,{children:["Please make sure the ",(0,i.jsx)(s.code,{children:"embassy_stm32"})," crate is included in your build either:"]}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["by importing it with ",(0,i.jsx)(s.code,{children:"use embassy_stm32 as _;"})]}),"\n",(0,i.jsx)(s.li,{children:"or by initialising the peripherals"}),"\n"]}),(0,i.jsxs)(s.p,{children:["This crate provides the ",(0,i.jsx)(s.strong,{children:"startup and linker sections"})," required for the STM32U545 to boot correctly."]})]}),(0,i.jsxs)(o.A,{value:"rp2350",label:"Raspberry Pi Pico 1 / 2",default:!0,children:[(0,i.jsxs)(s.p,{children:["Please make sure the ",(0,i.jsx)(s.code,{children:"embassy_rp"})," crate is included in your build either:"]}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["by importing it with ",(0,i.jsx)(s.code,{children:"use embassy_rp as _;"})]}),"\n",(0,i.jsx)(s.li,{children:"or by initialising the peripherals"}),"\n"]}),(0,i.jsxs)(s.p,{children:["This crate provides the ",(0,i.jsx)(s.code,{children:".start_block"})," section that is needed by the RP2350 to boot. Not including\nthis crate will prevent this section from being added and will prevent the RP2350 to boot."]})]})]})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(d.A,{children:[(0,i.jsxs)(o.A,{value:"vscode",label:"Visual Studio Code",default:!0,children:[(0,i.jsxs)(s.p,{children:["To prevent ",(0,i.jsx)(s.code,{children:"rust-analyzer"})," from showing an error on the first line and to automatically\nformat your source when saving, create a ",(0,i.jsx)(s.code,{children:".vscode/settings.json"})," file with:"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",children:'{\n  "rust-analyzer.cargo.allTargets": false,\n  "[rust]": {\n    "editor.defaultFormatter": "rust-lang.rust-analyzer",\n    "editor.formatOnSave": true,\n    "editor.formatOnSaveMode": "file"\n  }\n}\n'})})]}),(0,i.jsxs)(o.A,{value:"zed",label:"Zed",default:!0,children:[(0,i.jsxs)(s.p,{children:["To prevent ",(0,i.jsx)(s.code,{children:"rust-analyzer"})," from showing an error on the first line and to automatically\nformat your source when saving, create a ",(0,i.jsx)(s.code,{children:".zed/settings.json"})," file with:"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",children:'{\n  "lsp": {\n    "rust-analyzer": {\n      "initialization_options": {\n        "cargo": {\n          "target": "thumbv8m.main-none-eabihf",\n          "allTargets": false\n        }\n      }\n    }\n  },\n  "inlay_hints": {\n    "enabled": true\n  }\n}\n\n'})})]}),(0,i.jsxs)(o.A,{value:"helix",label:"Helix",default:!0,children:[(0,i.jsxs)(s.p,{children:["To prevent ",(0,i.jsx)(s.code,{children:"rust-analyzer"})," from showing an error on the first line and to automatically\nformat your source when saving, create a ",(0,i.jsx)(s.code,{children:".helix/congif.toml"})," file with:"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-toml",children:'[editor.inline-diagnostics]\ncursor-line = "error"\n\n[editor.file-picker]\nhidden = false\n\n[editor.lsp]\ndisplay-inlay-hints = true\n\n'})})]})]})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsxs)(s.li,{children:["Write a program using Embassy that set on LOW the LED connected to IO/D8 (PC7). (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(s.admonition,{type:"note",children:[(0,i.jsxs)(s.p,{children:["Please make sure you to put a ",(0,i.jsx)(s.code,{children:"loop {}"})," at the end of the ",(0,i.jsx)(s.code,{children:"main"})," function, otherwise Embassy will reset the\npins at the end of the function and you will not see the LED turn on."]}),(0,i.jsxs)(s.admonition,{type:"danger",children:[(0,i.jsx)(s.mdxAdmonitionTitle,{}),(0,i.jsx)(s.p,{children:"Please make sure the lab professor verifies your circuit before it is powered up."})]})]}),"\n",(0,i.jsxs)(s.ol,{start:"3",children:["\n",(0,i.jsxs)(s.li,{children:["Write a program using Embassy that blinks the LED connected to IO/D8 (PC7)\nevery 300ms. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["For the purpose of this lab, please use ",(0,i.jsx)(s.code,{children:"await"})," as is, think that for\nusing the ",(0,i.jsx)(s.code,{children:"Timer"}),", you have to add ",(0,i.jsx)(s.code,{children:".await"})," after the ",(0,i.jsx)(s.code,{children:"after"})," function."]})}),"\n",(0,i.jsxs)(s.ol,{start:"4",children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:['Write a program using Embassy that will write the\nmessage "The button was pressed" to the console every time button S1 is pressed.\nMake sure you connect the switch S1 to a STM32 Nucleo-U545RE-Q pin. (',(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:["Write a Rust program using Embassy that toggles the LED every time button S1 is pressed.\nThe message might be printed many times for one press? Why? (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["Read the value of S1 in a ",(0,i.jsx)(s.code,{children:"loop"})," and print the message if the value is ",(0,i.jsx)(s.code,{children:"LOW"}),"."]})}),"\n",(0,i.jsxs)(s.ol,{start:"6",children:["\n",(0,i.jsxs)(s.li,{children:["Instead of constantly sampling for the button value, use the ",(0,i.jsx)(s.a,{href:"#waiting-for-gpio-input",children:"wait pin functions"})," to\nwait for the value to change. Why is the message printed only once? (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["Do not forget to write the ",(0,i.jsx)(s.code,{children:".await"})," keyword at the end of an ",(0,i.jsx)(s.code,{children:"async"})," function call."]})}),"\n",(0,i.jsxs)(s.ol,{start:"7",children:["\n",(0,i.jsxs)(s.li,{children:["Build a traffic light using the ",(0,i.jsx)(s.code,{children:"LED_GREEN"}),", ",(0,i.jsx)(s.code,{children:"LED_YELLOW"})," and ",(0,i.jsx)(s.code,{children:"LED_RED"})," LEDs. (",(0,i.jsx)(s.strong,{children:"1p"}),") The flow of the colors\nis:"]}),"\n"]}),"\n",(0,i.jsx)(s.mermaid,{value:"flowchart LR\n    red(RED) -- 3s --\x3e green(Green)\n    green -- 3s --\x3e yellow(Yellow)\n    yellow -- 1s --\x3e red\n\n    classDef red fill:#ff0000,stroke:#000000,color: #ffffff\n    classDef yellow fill:#efa200,stroke:#000000\n    classDef green fill:#00ce54,stroke:#000000\n\n    class red red\n    class yellow yellow\n    class green green"}),"\n",(0,i.jsxs)(s.ol,{start:"8",children:["\n",(0,i.jsxs)(s.li,{children:["Extend the traffic light to include a flashing blue LED for pedestrians.\nWhen the pedestrian button is pressed, the traffic light switches to yellow\nand waits one second. After that, it switches on the red light and flashes\nthe blue pedestrian light. After 5 seconds, the traffic light switches back\nto green and stops the blue flashing. (",(0,i.jsx)(s.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.mermaid,{value:"flowchart LR\n    green(GREEN) --\x3e switch(Wait for pedestrian \n    button press)\n    switch --\x3e yellow(Yellow)\n    yellow -- 1s --\x3e red(RED)\n    yellow -- 1s --\x3e blue(BLUE blinking)\n    blue -- 5s --\x3e green\n\n    classDef red fill:#ff0000,stroke:#000000,color: #ffffff\n    classDef yellow fill:#efa200,stroke:#000000\n    classDef green fill:#00ce54,stroke:#000000\n    classDef blue fill:#009fff,stroke:#000000,color: #ffffff\n\n    class red red\n    class yellow yellow\n    class green green\n    class blue blue"}),"\n",(0,i.jsxs)(s.ol,{start:"9",children:["\n",(0,i.jsxs)(s.li,{children:["Display letters in Morse Code.","\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Write a function that takes as an argument a letter and displays\nit in Morse Code using three LEDs. For a dot light up the middle LED,\nfor a line light up all three. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Write a firmware that displays a text in Morse Code. (",(0,i.jsx)(s.strong,{children:"1p"}),")\n",(0,i.jsx)(s.img,{alt:"International Morse Code",src:n(18100).A+"",width:"414",height:"530"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["Letters in Morse Code are case insensitive. You can use the ",(0,i.jsx)(s.a,{href:"https://doc.rust-lang.org/beta/core/primitive.char.html#method.to_ascii_uppercase",children:(0,i.jsx)(s.code,{children:"char::to_ascii_uppercase"})}),"\nor ",(0,i.jsx)(s.a,{href:"https://doc.rust-lang.org/std/primitive.u8.html#method.to_ascii_uppercase",children:(0,i.jsx)(s.code,{children:"u8::to_ascii_uppercase"})})," functions to convert a ",(0,i.jsx)(s.code,{children:"char"})," or ",(0,i.jsx)(s.code,{children:"u8"})," to uppercase."]})}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsxs)(s.p,{children:["You can use an array of ",(0,i.jsx)(s.code,{children:"&str"}),"s to store the format of the morse code."]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:'const CODES: [&str; 26] = [\n    ".-", // A\n    // ...\n];\n'})})]})]})}function x(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},19365:(e,s,n)=>{n.d(s,{A:()=>a});n(96540);var t=n(34164);const i={tabItem:"tabItem_Ymn6"};var r=n(74848);function a({children:e,hidden:s,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(i.tabItem,n),hidden:s,children:e})}},11470:(e,s,n)=>{n.d(s,{A:()=>I});var t=n(96540),i=n(34164),r=n(17559),a=n(23104),d=n(56347),o=n(205),l=n(57485),c=n(31682),h=n(70679);function m(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:s}=e;return!!s&&"object"==typeof s&&"value"in s}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:s,children:n}=e;return(0,t.useMemo)((()=>{const e=s??function(e){return m(e).map((({props:{value:e,label:s,attributes:n,default:t}})=>({value:e,label:s,attributes:n,default:t})))}(n);return function(e){const s=(0,c.XI)(e,((e,s)=>e.value===s.value));if(s.length>0)throw new Error(`Docusaurus error: Duplicate values "${s.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[s,n])}function p({value:e,tabValues:s}){return s.some((s=>s.value===e))}function x({queryString:e=!1,groupId:s}){const n=(0,d.W6)(),i=function({queryString:e=!1,groupId:s}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:e,groupId:s});return[(0,l.aZ)(i),(0,t.useCallback)((e=>{if(!i)return;const s=new URLSearchParams(n.location.search);s.set(i,e),n.replace({...n.location,search:s.toString()})}),[i,n])]}function f(e){const{defaultValue:s,queryString:n=!1,groupId:i}=e,r=u(e),[a,d]=(0,t.useState)((()=>function({defaultValue:e,tabValues:s}){if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=s.find((e=>e.default))??s[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:s,tabValues:r}))),[l,c]=x({queryString:n,groupId:i}),[m,f]=function({groupId:e}){const s=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,i]=(0,h.Dv)(s);return[n,(0,t.useCallback)((e=>{s&&i.set(e)}),[s,i])]}({groupId:i}),j=(()=>{const e=l??m;return p({value:e,tabValues:r})?e:null})();(0,o.A)((()=>{j&&d(j)}),[j]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);d(e),c(e),f(e)}),[c,f,r]),tabValues:r}}var j=n(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(74848);function y({className:e,block:s,selectedValue:n,selectValue:t,tabValues:r}){const d=[],{blockElementScrollPositionUntilNextRender:o}=(0,a.a_)(),l=e=>{const s=e.currentTarget,i=d.indexOf(s),a=r[i].value;a!==n&&(o(s),t(a))},c=e=>{let s=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;s=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;s=d[n]??d[d.length-1];break}}s?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":s},e),children:r.map((({value:e,label:s,attributes:t})=>(0,g.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{d.push(e)},onKeyDown:c,onClick:l,...t,className:(0,i.A)("tabs__item",b.tabItem,t?.className,{"tabs__item--active":n===e}),children:s??e},e)))})}function w({lazy:e,children:s,selectedValue:n}){const r=(Array.isArray(s)?s:[s]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===n));return e?(0,t.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:r.map(((e,s)=>(0,t.cloneElement)(e,{key:s,hidden:e.props.value!==n})))})}function v(e){const s=f(e);return(0,g.jsxs)("div",{className:(0,i.A)(r.G.tabs.container,"tabs-container",b.tabList),children:[(0,g.jsx)(y,{...s,...e}),(0,g.jsx)(w,{...s,...e})]})}function I(e){const s=(0,j.A)();return(0,g.jsx)(v,{...e,children:m(e.children)},String(s))}},75137:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/exti_line_connections-4bfa1ff8631c55b3f9b07c43f78697bf.png"},74493:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/exti_mux_gpio-9a2bad6404ec02787b395183dd3ee02d.png"},24712:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/gpio_mux-e4a348a45def684b56fdace777269f64.png"},18100:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/international_morse_code-4f915afa04938b9fedff8a08c8050a8f.svg"},21668:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/lab_board-68f39478a171a3ee9a911ed6c50b67ef.jpg"},65874:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/lab_board_connectors-41a6ead27ceb0c36ba10cb00323a8859.jpeg"},59729:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/lab_board_gp-2f75d13c20589c11885c6ce651c7366a.jpeg"},13589:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/lab_board_wired-697e64c8728907667b4b5681fc1127e6.jpeg"},54707:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/pico2w-pinout-49532ea10ab0caedc6a6f21d1bf504bf.svg"},73297:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/rust_embedded_stack-8b3f636797a4c516d4202359f33d0143.svg"},79698:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/stm32u5-pinout-101fa7dc84d69045ebdec72326c1db46.jpeg"},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>d});var t=n(96540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);