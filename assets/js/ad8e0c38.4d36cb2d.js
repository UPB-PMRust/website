"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2779],{93095:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"project/2025/ovidiu.andreescu/index","title":"STM32 Retro Console","description":"A portable gaming console in Rust, featuring a custom BIOS, a virtual machine emulating CHIP-8 ISA, and a game library loaded from an SD card.","source":"@site/versioned_docs/version-fils_en/project/2025/ovidiu.andreescu/index.md","sourceDirName":"project/2025/ovidiu.andreescu","slug":"/project/2025/ovidiu.andreescu/","permalink":"/docs/fils_en/project/2025/ovidiu.andreescu/","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/versioned_docs/version-fils_en/project/2025/ovidiu.andreescu/index.md","tags":[],"version":"fils_en","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Smart Door","permalink":"/docs/fils_en/project/2025/octavian.cretu/"},"next":{"title":"Mood Tracker","permalink":"/docs/fils_en/project/2025/pconstantinescu0206/"}}');var a=s(74848),r=s(28453);const t={},d="STM32 Retro Console",c={},l=[{value:"Description",id:"description",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Log",id:"log",level:2},{value:"Week - 15 December - 21 December",id:"week---15-december---21-december",level:3},{value:"Week - 29 December - 4 January",id:"week---29-december---4-january",level:3},{value:"Week - 5 January - 11 January",id:"week---5-january---11-january",level:3},{value:"Week - 12 January - 18 January",id:"week---12-january---18-january",level:3},{value:"Hardware",id:"hardware",level:2},{value:"Schematics",id:"schematics",level:3},{value:"Bill of Materials",id:"bill-of-materials",level:3},{value:"Software",id:"software",level:2},{value:"Links",id:"links",level:2}];function o(e){const n={a:"a",admonition:"admonition",annotation:"annotation",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"stm32-retro-console",children:"STM32 Retro Console"})}),"\n",(0,a.jsx)(n.p,{children:"A portable gaming console in Rust, featuring a custom BIOS, a virtual machine emulating CHIP-8 ISA, and a game library loaded from an SD card."}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Author"}),": Andreescu Ovidiu-\u0218tefan ",(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.strong,{children:"GitHub Project Link"}),": ",(0,a.jsx)(n.a,{href:"https://github.com/UPB-PMRust-Students/project-dm-2025-ovidiu-andreescu",children:"https://github.com/UPB-PMRust-Students/project-dm-2025-ovidiu-andreescu"})]})}),"\n",(0,a.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"The STM32 Retro Console is a handheld embedded system designed to run classic retro games on resource-constrained hardware. It is built around the STM32F767ZI microcontroller and implements a complete CHIP-8 virtual machine capable of executing game logic, handling input, graphics, and sound in real time."}),"\n",(0,a.jsx)(n.p,{children:"The system boots into a custom BIOS shell that initializes all peripherals and provides a simple menu interface for selecting game ROMs stored on an SD card. The BIOS manages SD card access, on-screen navigation, and basic user feedback before transferring control to the virtual machine."}),"\n",(0,a.jsx)(n.p,{children:"Game graphics are rendered on a 128\xd764 OLED display via I\xb2C, user input is handled through a matrix keypad connected to GPIO pins, and sound effects are generated using a PWM-controlled buzzer."}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(n.p,{children:"I chose this project to validate the full embedded development stack in Rust, from hardware bring-up to application logic. Specifically, I wanted to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use a virtual machine (CHIP-8) to understand low-level instruction parsing."}),"\n",(0,a.jsx)(n.li,{children:"Create a complete system that boots independently and manages a file system, rather than running a single hardcoded script."}),"\n",(0,a.jsx)(n.li,{children:"Demonstrate interactivity by integrating display drivers, audio feedback, and matrix keypad input into a single portable device."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsxs)(n.p,{children:["The system architecture is centered around the ",(0,a.jsx)(n.strong,{children:"STM32F767ZI"})," microcontroller, which acts as the host for the CHIP-8 interpreter."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Main Components & Connections:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Core System (STM32):"})," Handles the fetch-decode-execute cycle of the VM and manages peripheral timing."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Storage Subsystem:"})," An ",(0,a.jsx)(n.strong,{children:"SD Card Module"})," connects via SPI to provide a dynamic file system. The BIOS reads this to list and load ",(0,a.jsx)(n.code,{children:".ch8"})," ROM files into RAM."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Human Interface (Input):"})," A ",(0,a.jsxs)(n.strong,{children:[(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mn,{children:"4"}),(0,a.jsx)(n.mo,{children:"\xd7"}),(0,a.jsx)(n.mn,{children:"4"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"4\\times4"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(n.span,{className:"mord",children:"4"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"4"})]})]})]})," Matrix Keypad"]})," is scanned via GPIO to map physical button presses to the 16-key CHIP-8 layout."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Human Interface (Output):"})}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"OLED Display:"})," Connects via I2C/SPI to render the ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mn,{children:"64"}),(0,a.jsx)(n.mo,{children:"\xd7"}),(0,a.jsx)(n.mn,{children:"32"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"64\\times32"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(n.span,{className:"mord",children:"64"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"32"})]})]})]})," monochrome graphics buffer."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Passive Buzzer:"})," Connects via PWM/GPIO to generate simple square wave tones for game sound."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Architecture Block Diagram",src:s(93805).A+"",width:"819",height:"768"})}),"\n",(0,a.jsx)(n.h2,{id:"log",children:"Log"}),"\n",(0,a.jsx)(n.h3,{id:"week---15-december---21-december",children:"Week - 15 December - 21 December"}),"\n",(0,a.jsx)(n.p,{children:"Focused on hardware bring-up and initial validation. Connected and verified all peripheral\ncomponents (STM32F767ZI, OLED display, keypad, SD card module, buzzer). Implemented and tested low-level initialization\ncode for GPIO, I2C, SPI, timers, and PWM to ensure stable communication with all devices."}),"\n",(0,a.jsx)(n.h3,{id:"week---29-december---4-january",children:"Week - 29 December - 4 January"}),"\n",(0,a.jsx)(n.p,{children:"Designed and implemented the BIOS layer. Developed the display driver integration, keypad scanning logic, and basic audio\nfeedback. Implemented the SD card initialization and filesystem access logic, including directory scanning and file selection,\nand added a fallback."}),"\n",(0,a.jsx)(n.h3,{id:"week---5-january---11-january",children:"Week - 5 January - 11 January"}),"\n",(0,a.jsx)(n.p,{children:"Integrated the BIOS with the main application logic. Connected the BIOS ROM loader to the CHIP-8 virtual machine, ensured correct\nmemory loading and execution flow, and implemented input mapping between the physical keypad and the CHIP-8 key layout. Refined timing,\nrendering, and control handoff between BIOS and emulator."}),"\n",(0,a.jsx)(n.h3,{id:"week---12-january---18-january",children:"Week - 12 January - 18 January"}),"\n",(0,a.jsx)(n.p,{children:"Focused on testing, debugging, and performance improvements. Fixed issues related to SD card reliability, opcode handling,\ninput responsiveness, and display update speed. Tuned execution and rendering frequency, validated multiple CHIP-8 games,\nand ensured stable gameplay across different ROMs."}),"\n",(0,a.jsx)(n.h2,{id:"hardware",children:"Hardware"}),"\n",(0,a.jsx)(n.p,{children:"The project utilizes an STM32F767ZI Nucleo-144 board as the central processing unit, interfacing with a 128x64 OLED display via\nSPI/I2C for video output. User interaction is handled through a 4x4 matrix keypad scanned via GPIO, while game assets are\nloaded dynamically from an SD card module and audio is output through a passive buzzer."}),"\n",(0,a.jsx)(n.h3,{id:"schematics",children:"Schematics"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"KiCAD Schematic Placeholder",src:s(85722).A+"",width:"794",height:"559"})}),"\n",(0,a.jsx)(n.h3,{id:"bill-of-materials",children:"Bill of Materials"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Device"}),(0,a.jsx)(n.th,{children:"Usage"}),(0,a.jsx)(n.th,{children:"Price"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"[STM32F767ZI Nucleo]"}),(0,a.jsx)(n.td,{children:"The main microcontroller board"}),(0,a.jsx)(n.td,{children:"~130 RON"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:'[1.3" OLED Display]'}),(0,a.jsx)(n.td,{children:"128x64 Screen for rendering game graphics"}),(0,a.jsx)(n.td,{children:"~25 RON"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"[4x4 Matrix Keypad]"}),(0,a.jsx)(n.td,{children:"User input for game controls (16 keys)"}),(0,a.jsx)(n.td,{children:"~10 RON"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"[SD Card Module]"}),(0,a.jsx)(n.td,{children:"Interfacing with the SD card to load ROMs"}),(0,a.jsx)(n.td,{children:"~10 RON"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"[Passive Buzzer]"}),(0,a.jsx)(n.td,{children:"Audio feedback (beeps/tones)"}),(0,a.jsx)(n.td,{children:"~12 RON"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"software",children:"Software"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Library"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Usage"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"stm32f7xx-hal + embassy"})}),(0,a.jsx)(n.td,{children:"Hardware Abstraction Layer"}),(0,a.jsx)(n.td,{children:"Configures GPIO, SPI, and Timers for the STM32F7"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"embedded-graphics"})}),(0,a.jsx)(n.td,{children:"2D graphics library"}),(0,a.jsx)(n.td,{children:"Drawing pixels and text to the display buffer"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"ssd1306"})}),(0,a.jsx)(n.td,{children:"Display Driver"}),(0,a.jsx)(n.td,{children:"Initializes and sends data to the OLED screen"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"embedded-sdmmc"})}),(0,a.jsx)(n.td,{children:"File System Library"}),(0,a.jsx)(n.td,{children:"Reading FAT32 file systems on the SD card"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"cortex-m-rt"})}),(0,a.jsx)(n.td,{children:"Runtime Crate"}),(0,a.jsx)(n.td,{children:"Startup code and entry point for bare metal execution"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/kurtjd/CHIPnGo",children:"CHIPnGo - Inspiration"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/AlfonsoJLuna/chip8stm32",children:"chip8stm32 - Inspiration"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"http://devernay.free.fr/hacks/chip8/C8TECH.htlm",children:"Cowgod's CHIP-8 Technical Reference"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},93805:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/architecture-12ec87b78afa3a7b17809f3fb1d28f64.webp"},85722:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/hardware-3e4dc70ebcb26ea47eeac9c17ba0e624.svg"},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>d});var i=s(96540);const a={},r=i.createContext(a);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);